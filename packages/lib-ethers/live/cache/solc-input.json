{
  "language": "Solidity",
  "sources": {
    "contracts/ActivePool.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport './Interfaces/IPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract ActivePool is Ownable, IPool {\n    using SafeMath for uint256;\n\n    address public poolManagerAddress;\n    address public troveManagerAddress;\n    address public defaultPoolAddress;\n    uint256 internal ETH;  // deposited ether tracker\n    uint256 internal LUSDDebt;\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    // --- Modifiers ---\n   \n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"ActivePool: Caller is not the PoolManager\");\n        _;\n    }\n\n    modifier onlyPoolManagerOrDefaultPool {\n        require(\n            _msgSender() == poolManagerAddress || \n            _msgSender() == defaultPoolAddress,\n            \"ActivePool: Caller is neither the PoolManager nor Default Pool\");\n        _;\n    }\n\n    modifier onlyPoolManagerOrTroveManager {\n        require(\n            _msgSender() == poolManagerAddress || \n            _msgSender() == troveManagerAddress, \n            \"ActivePool: Caller is neither the PoolManager nor TroveManager\");\n        _;\n    }\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _poolManagerAddress,\n        address _troveManagerAddress,\n        address _defaultPoolAddress\n    )\n        external\n        onlyOwner\n    {\n        poolManagerAddress = _poolManagerAddress;\n        troveManagerAddress = _troveManagerAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view returns (uint) {\n        return ETH;\n    }\n\n    function getLUSDDebt() external view returns (uint) {\n        return LUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) public onlyPoolManagerOrTroveManager {\n        ETH = ETH.sub(_amount);  \n        emit EtherSent(_account, _amount);  \n\n        (bool success, ) = _account.call.value(_amount)(\"\"); //  use call.value()('') as per Consensys latest advice \n        require(success, \"ActivePool: sending ETH failed\");\n    }\n\n    function increaseLUSDDebt(uint _amount) external onlyPoolManager () {\n        LUSDDebt  = LUSDDebt.add(_amount); \n    }\n\n    function decreaseLUSDDebt(uint _amount) external onlyPoolManager () {\n        LUSDDebt = LUSDDebt.sub(_amount); \n    }\n\n    /* Returns the raw ether balance at ActivePool address.  \n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\n    function getRawETHBalance() external view returns (uint) {\n        return address(this).balance;\n    }\n\n    function () external payable onlyPoolManagerOrDefaultPool {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/Interfaces/IPool.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// Common interface for the Pools.\ninterface IPool {\n    // --- Events ---\n    event ETHBalanceUpdated(uint _newBalance);\n\n    event LUSDBalanceUpdated(uint _newBalance);\n\n    event PoolManagerAddressChanged(address _newAddress);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    function getETH() external view returns (uint);\n    \n    function getLUSDDebt() external view returns (uint);\n    \n    function sendETH(address _account, uint _amount) external;\n\n    function increaseLUSDDebt(uint _amount) external;\n\n    function decreaseLUSDDebt(uint _amount) external;\n\n    function getRawETHBalance() external view returns (uint);\n}"
    },
    "contracts/Dependencies/SafeMath.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Dependencies/Ownable.sol": {
      "content": "pragma solidity >=0.5.16;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\n     * NOTE: This function is not safe, as it doesn’t check owner is calling it.\n     * Make sure you check it before calling it.\n     */\n    function _renounceOwnership() internal {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n}\n"
    },
    "contracts/Dependencies/Context.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Dependencies/console.sol": {
      "content": "pragma solidity >= 0.5.0 <0.7.0;\n// Buidler's helper contract for console logging\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IPool.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Interfaces/IPoolManager.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, IBorrowerOperations {\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    IPoolManager public poolManager;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IPriceFeed public priceFeed;\n\n    // A doubly linked list of CDPs, sorted by their sorted by their collateral ratios\n    ISortedCDPs public sortedCDPs;\n\n    // --- Events --- \n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        addColl,\n        withdrawColl,\n        withdrawLUSD,\n        repayLUSD,\n        adjustTrove\n    }\n\n    event CDPCreated(address indexed _user, uint arrayIndex);\n    event CDPUpdated(address indexed _user, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n\n    // --- Dependency setters --- \n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _poolManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _priceFeedAddress,\n        address _sortedCDPsAddress\n    )\n        external\n        onlyOwner\n    {\n        troveManager = ITroveManager(_troveManagerAddress);\n        poolManager = IPoolManager(_poolManagerAddress);\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedCDPsAddressChanged(_sortedCDPsAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint _LUSDAmount, address _hint) external payable {\n        address user = _msgSender(); \n        uint price = priceFeed.getPrice(); \n\n        _requireCDPisNotActive(user);\n        \n        uint compositeDebt = _getCompositeDebt(_LUSDAmount);\n        assert(compositeDebt > 0);\n        uint ICR = Math._computeCR(msg.value, compositeDebt, price);  \n\n        if (_checkRecoveryMode()) {\n            require(ICR >= R_MCR, \"BorrowerOps: In Recovery Mode new troves must have ICR >= R_MCR\");\n        } else {\n            _requireICRisAboveMCR(ICR);\n            _requireNewTCRisAboveCCR(int(msg.value), int(_LUSDAmount), price);\n        }\n\n        // Update trove properties\n        troveManager.setCDPStatus(user, 1);\n        troveManager.increaseCDPColl(user, msg.value);\n        troveManager.increaseCDPDebt(user, compositeDebt);\n        \n        troveManager.updateCDPRewardSnapshots(user); \n        uint stake = troveManager.updateStakeAndTotalStakes(user); \n        \n        sortedCDPs.insert(user, ICR, price, _hint, _hint); \n        uint arrayIndex = troveManager.addCDPOwnerToArray(user);\n        emit CDPCreated(user, arrayIndex);\n        \n        // Tell PM to move the ether to the Active Pool, and mint LUSD to the borrower\n        poolManager.addColl.value(msg.value)(); \n        poolManager.withdrawLUSD(user, _LUSDAmount);\n        poolManager.lockLUSDGasCompensation(LUSD_GAS_COMPENSATION);\n       \n        emit CDPUpdated(user, _LUSDAmount, msg.value, stake, BorrowerOperation.openTrove);\n    }\n\n    // Send ETH as collateral to a CDP\n    function addColl(address _user, address _hint) external payable {\n        _requireCDPisActive(_user);\n\n        uint price = priceFeed.getPrice();\n    \n        troveManager.applyPendingRewards(_user);\n       \n        // Update the CDP's coll and stake\n        uint newColl = troveManager.increaseCDPColl(_user, msg.value);\n        uint stake = troveManager.updateStakeAndTotalStakes(_user);\n        uint newICR = troveManager.getCurrentICR(_user, price);\n   \n        sortedCDPs.reInsert(_user, newICR, price, _hint, _hint);  \n       \n        // Tell PM to move the ether to the Active Pool\n        poolManager.addColl.value(msg.value)();\n  \n        uint debt = troveManager.getCDPDebt(_user);\n        emit CDPUpdated(_user, debt, newColl, stake, BorrowerOperation.addColl);\n    }\n    \n    // Withdraw ETH collateral from a CDP\n    function withdrawColl(uint _amount, address _hint) external {\n        address user = _msgSender();\n        _requireCDPisActive(user);\n        _requireNonZeroAmount(_amount);\n        _requireNotInRecoveryMode();\n       \n        uint price = priceFeed.getPrice();\n        troveManager.applyPendingRewards(user);\n\n        uint debt = troveManager.getCDPDebt(user);\n        uint coll = troveManager.getCDPColl(user);\n        \n        _requireCollAmountIsWithdrawable(coll, _amount);\n\n        uint newICR = _getNewICRFromTroveChange(coll, debt, -int(_amount), 0, price);\n        _requireICRisAboveMCR(newICR);\n        \n        // Update the CDP's coll and stake\n        uint newColl = troveManager.decreaseCDPColl(user, _amount);\n        uint stake = troveManager.updateStakeAndTotalStakes(user);\n\n        if (newColl == 0) { \n            troveManager.closeCDP(user);  \n        }  else { \n            sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n        }\n\n        // Remove _amount ETH from ActivePool and send it to the user\n        poolManager.withdrawColl(user, _amount);\n\n        emit CDPUpdated(user, debt, newColl, stake, BorrowerOperation.withdrawColl);\n    }\n    \n    // Withdraw LUSD tokens from a CDP: mint new LUSD to the owner, and increase the debt accordingly\n    function withdrawLUSD(uint _amount, address _hint) external {\n        address user = _msgSender();\n        _requireCDPisActive(user);\n        _requireNonZeroAmount(_amount); \n        _requireNotInRecoveryMode();\n        \n        uint price = priceFeed.getPrice();\n        troveManager.applyPendingRewards(user);\n\n        uint coll = troveManager.getCDPColl(user);\n        uint debt = troveManager.getCDPDebt(user);\n\n        uint newICR = _getNewICRFromTroveChange(coll, debt, 0, int(_amount), price);\n        _requireICRisAboveMCR(newICR);\n\n        _requireNewTCRisAboveCCR(0, int(_amount), price);\n        \n        // Increase the CDP's debt\n        uint newDebt = troveManager.increaseCDPDebt(user, _amount);\n       \n        // Update CDP's position in sortedCDPs\n        sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n\n        // Mint the given amount of LUSD to the owner's address and add them to the ActivePool\n        poolManager.withdrawLUSD(user, _amount);\n        \n        uint stake = troveManager.getCDPStake(user);\n        emit CDPUpdated(user, newDebt, coll, stake, BorrowerOperation.withdrawLUSD);\n    }\n    \n    // Repay LUSD tokens to a CDP: Burn the repaid LUSD tokens, and reduce the debt accordingly\n    function repayLUSD(uint _amount, address _hint) external {\n        address user = _msgSender();\n        _requireCDPisActive(user);\n        _requireNonZeroAmount(_amount);\n\n        uint price = priceFeed.getPrice();\n        troveManager.applyPendingRewards(user);\n\n        uint debt = troveManager.getCDPDebt(user);\n        _requireLUSDRepaymentAllowed(debt, -int(_amount));\n        \n        // Update the CDP's debt\n        uint newDebt = troveManager.decreaseCDPDebt(user, _amount);\n       \n        uint newICR = troveManager.getCurrentICR(user, price);\n        \n        // Update CDP's position in sortedCDPs\n        sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n\n        // Burn the received amount of LUSD from the user's balance, and remove it from the ActivePool\n        poolManager.repayLUSD(user, _amount);\n        \n        uint coll = troveManager.getCDPColl(user);\n        uint stake = troveManager.getCDPStake(user);\n        emit CDPUpdated(user, newDebt, coll, stake, BorrowerOperation.repayLUSD);\n    }\n\n    function closeTrove() external {\n        address user = _msgSender();\n        _requireCDPisActive(user);\n        _requireNotInRecoveryMode();\n\n        troveManager.applyPendingRewards(user);\n        \n        uint coll = troveManager.getCDPColl(user);\n        uint debt = troveManager.getCDPDebt(user);\n\n        troveManager.removeStake(user);\n        troveManager.closeCDP(user);\n    \n        // Tell PM to burn the debt from the user's balance, and send the collateral back to the user\n        poolManager.repayLUSD(user, debt.sub(LUSD_GAS_COMPENSATION));\n        poolManager.withdrawColl(user, coll);\n        poolManager.refundLUSDGasCompensation(LUSD_GAS_COMPENSATION);\n\n        emit CDPUpdated(user, 0, 0, 0, BorrowerOperation.closeTrove);\n    }\n\n    /* If ether is sent, the operation is considered as an increase in ether, and the first parameter \n    _collWithdrawal is ignored  */\n    function adjustTrove(uint _collWithdrawal, int _debtChange, address _hint) external payable {\n        address user = _msgSender();\n        _requireCDPisActive(user);\n        _requireNotInRecoveryMode();\n        \n        uint price = priceFeed.getPrice();\n     \n        troveManager.applyPendingRewards(user);\n\n        // If Ether is sent, grab the amount. Otherwise, grab the specified collateral withdrawal\n        int collChange = (msg.value != 0) ? int(msg.value) : -int(_collWithdrawal);\n\n        uint debt = troveManager.getCDPDebt(user);\n        uint coll = troveManager.getCDPColl(user);\n       \n        uint newICR = _getNewICRFromTroveChange(coll, debt, collChange, _debtChange, price);\n       \n        // --- Checks --- \n        _requireICRisAboveMCR(newICR);\n        _requireNewTCRisAboveCCR(collChange, _debtChange, price);\n        _requireLUSDRepaymentAllowed(debt, _debtChange);\n        _requireCollAmountIsWithdrawable(coll, _collWithdrawal);\n\n        //  --- Effects --- \n        (uint newColl, uint newDebt) = _updateTroveFromAdjustment(user, collChange, _debtChange);\n        \n        uint stake = troveManager.updateStakeAndTotalStakes(user);\n       \n        // Close a CDP if it is empty, otherwise, re-insert it in the sorted list\n        if (newDebt == 0 && newColl == 0) {\n            troveManager.closeCDP(user);\n        } else {\n            sortedCDPs.reInsert(user, newICR, price, _hint, _hint);\n        }\n\n        //  --- Interactions ---\n        _moveTokensAndETHfromAdjustment(user, collChange, _debtChange);   \n    \n        emit CDPUpdated(user, newDebt, newColl, stake, BorrowerOperation.adjustTrove);\n    }\n\n    // --- Helper functions --- \n    \n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(1e18);\n\n        return usdValue;\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(address _user, int _collChange, int _debtChange ) internal returns (uint, uint) {\n        uint newColl = (_collChange > 0) ? troveManager.increaseCDPColl(_user, Math._intToUint(_collChange)) \n                                         : troveManager.decreaseCDPColl(_user, Math._intToUint(_collChange));\n        uint newDebt = (_debtChange > 0) ? troveManager.increaseCDPDebt(_user, Math._intToUint(_debtChange)) \n                                         : troveManager.decreaseCDPDebt(_user, Math._intToUint(_debtChange));\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment(address _user, int _collChange, int _debtChange) internal {\n        if (_debtChange > 0){\n            poolManager.withdrawLUSD(_user, Math._intToUint(_debtChange));\n        } else if (_debtChange < 0) {\n            poolManager.repayLUSD(_user, Math._intToUint(_debtChange));\n        }\n\n        if (_collChange > 0 ) {\n            poolManager.addColl.value(Math._intToUint(_collChange))();\n        } else if (_collChange < 0) {\n            poolManager.withdrawColl(_user, Math._intToUint(_collChange));\n        }\n    }\n    \n    // --- 'Require' wrapper functions ---\n\n    function _requireCDPisActive(address _user) internal view {\n        uint status = troveManager.getCDPStatus(_user);\n        require(status == 1, \"BorrowerOps: CDP does not exist or is closed\");\n    }\n\n    function _requireCDPisNotActive(address _user) internal view {\n        uint status = troveManager.getCDPStatus(_user);\n        require(status != 1, \"BorrowerOps: CDP is active\");\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(_checkRecoveryMode() == false, \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireICRisAboveMCR(uint _newICR)  internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireNewTCRisAboveCCR(int _collChange, int _debtChange, uint _price) internal view {\n        uint newTCR = _getNewTCRFromTroveChange(_collChange, _debtChange, _price);\n        require(newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireLUSDRepaymentAllowed(uint _currentDebt, int _debtChange) internal pure {\n        if (_debtChange < 0) {\n            require(Math._intToUint(_debtChange) <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the CDP's debt\");\n        }\n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, \"BorrowerOps: Amount must be larger than 0\");\n    }\n\n    function _requireCollAmountIsWithdrawable(uint _currentColl, uint _collWithdrawal)\n    internal \n    pure \n    {\n        require(_collWithdrawal <= _currentColl, \"BorrowerOps: Insufficient balance for ETH withdrawal\");\n    }\n\n    // --- ICR and TCR checks ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. \n    function _getNewICRFromTroveChange(uint _coll, uint _debt, int _collChange, int _debtChange, uint _price) \n    pure\n    internal \n    returns (uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        if (_collChange > 0) {\n            newColl = _coll.add(Math._intToUint(_collChange));\n        } else if (_collChange < 0) {\n            newColl = _coll.sub(Math._intToUint(_collChange));\n        }\n\n        if (_debtChange > 0) {\n            newDebt = _debt.add(Math._intToUint(_debtChange));\n        } else if (_debtChange < 0) {\n            newDebt = _debt.sub(Math._intToUint(_debtChange));\n        }\n\n        uint newICR = Math._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(int _collChange, int _debtChange, uint _price) internal view returns (uint) {\n        uint totalColl = activePool.getETH().add(defaultPool.getETH());\n        uint totalDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n       \n        if (_collChange > 0) {\n            totalColl = totalColl.add(Math._intToUint(_collChange));\n        } else if (_collChange < 0) {\n            totalColl = totalColl.sub(Math._intToUint(_collChange));\n        }\n\n        if (_debtChange > 0) {\n            totalDebt = totalDebt.add(Math._intToUint(_debtChange));\n        } else if (_debtChange < 0) {\n            totalDebt = totalDebt.sub(Math._intToUint(_debtChange));\n        }\n\n        uint newTCR = Math._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function _checkRecoveryMode() internal view returns (bool) {\n        uint TCR = _getTCR();\n        \n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _getTCR() internal view returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint activeColl = activePool.getETH();\n        uint activeDebt = activePool.getLUSDDebt();\n        uint liquidatedColl = defaultPool.getETH();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        uint totalCollateral = activeColl.add(liquidatedColl);\n        uint totalDebt = activeDebt.add(closedDebt); \n\n        TCR = Math._computeCR(totalCollateral, totalDebt, price);\n\n        return TCR;\n    }\n}\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// Common interface for the CDP Manager.\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    \n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _poolManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _priceFeedAddress,\n        address _sortedCDPsAddress\n    ) external;\n\n    function openTrove(uint _LUSDAmount, address _hint) external payable;\n\n    function addColl(address _user, address _hint) external payable;\n\n    function withdrawColl(uint _amount, address _hint) external;\n\n    function withdrawLUSD(uint _amount, address _hint) external;\n\n    function repayLUSD(uint _amount, address _hint) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(uint _collWithdrawal, int _debtChange, address _hint) external payable;\n\n    function getCompositeDebt(uint _debt) external pure returns (uint);\n}"
    },
    "contracts/Interfaces/ITroveManager.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// Common interface for the CDP Manager.\ninterface ITroveManager {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    \n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n\n    event CDPCreated(address indexed _user, uint arrayIndex);\n\n    event CDPUpdated(address indexed _user, uint _debt, uint _coll, uint stake, uint8 operation);\n\n    event CDPLiquidated(address indexed _user, uint _debt, uint _coll, uint8 operation);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _poolManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedCDPsAddress\n    ) external;\n\n    function getCDPOwnersCount() external view returns (uint);\n\n    function getTroveFromCDPOwnersArray(uint _index) external view returns (address);\n\n    function getCurrentICR(address _user, uint _price) external view returns (uint);\n\n    function liquidate(address _user) external;\n\n    function liquidateCDPs(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function checkRecoveryMode() external view returns (bool);\n\n    function redeemCollateral(\n        uint _LUSDAmount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    ) external; \n\n    function updateStakeAndTotalStakes(address _user) external returns (uint);\n\n    function updateCDPRewardSnapshots(address _user) external;\n\n    function addCDPOwnerToArray(address _user) external returns (uint index);\n\n    function applyPendingRewards(address _user) external;\n\n    function getPendingETHReward(address _user) external view returns (uint);\n\n    function getPendingLUSDDebtReward(address _user) external view returns (uint);\n\n    function closeCDP(address _user) external;\n\n    function removeStake(address _user) external;\n\n    function getCDPStatus(address _user) external view returns (uint);\n    \n    function getCDPStake(address _user) external view returns (uint);\n\n    function getCDPDebt(address _user) external view returns (uint);\n\n    function getCDPColl(address _user) external view returns (uint);\n\n    function setCDPStatus(address _user, uint num) external;\n\n    function increaseCDPColl(address _user, uint _collIncrease) external returns (uint);\n\n    function decreaseCDPColl(address _user, uint _collDecrease) external returns (uint); \n\n    function increaseCDPDebt(address _user, uint _debtIncrease) external returns (uint); \n\n    function decreaseCDPDebt(address _user, uint _collDecrease) external returns (uint); \n}"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IPriceFeed { \n    // --- Events ---\n    event PriceUpdated(uint _newPrice);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event PoolManagerAddressChanged(address _poolManagerAddress);\n\n    // --- Functions ---\n    function setAddresses(\n        address _troveManagerAddress,\n        address _poolManagerAddress,\n        address _priceAggregatorAddress,\n        address _priceAggregatorAddressTestnet\n    ) external;\n\n    function setPrice(uint _price) external returns (bool);\n        \n    function getPrice() external view returns (uint);\n\n    // --- Chainlink Mainnet functions ---\n    function updatePrice() external returns (uint256);\n\n    function getLatestPrice() external view returns (uint256);\n\n    function getLatestAnswerID() external view returns (uint256);\n\n    function getLatestTimestamp() external view returns (uint256);\n\n    // --- Chainlink Testnet functions --- \n    function updatePrice_Testnet() external returns (uint256);\n\n    function getLatestPrice_Testnet() external view returns (uint256);\n\n    function getLatestTimestamp_Testnet() external view returns (uint256);\n\n    function getPreviousPrice_Testnet(uint256 _n) external view returns (uint256);\n\n    function getPreviousTimestamp_Testnet(uint256 _n) external view returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ISortedCDPs.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// Common interface for the SortedCDPs Doubly Linked List.\ninterface ISortedCDPs {\n// --- Events ---\nevent SortedCDPsAddressChanged(address _sortedDoublyLLAddress);\nevent BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n// --- Functions ---\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\n\n    function insert(address _id, uint256 _ICR, uint price, address _prevId, address _nextId) external;\n\n    function remove(address _id) external;\n\n    function reInsert(address _id, uint256 _newICR, uint price, address _prevId, address _nextId) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) external view returns (bool);\n\n    function findInsertPosition(uint256 _ICR, uint _price,  address _prevId, address _nextId) external view returns (address, address);\n}"
    },
    "contracts/Interfaces/IPoolManager.sol": {
      "content": "pragma solidity >=0.5.16;\n\n// Common interface for the ETH/LUSD pools.\ninterface IPoolManager {\n     // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event UserSnapshotUpdated(uint _P, uint _S);\n\n    event P_Updated(uint _P);\n\n    event S_Updated(uint _S);\n\n    event UserDepositChanged(address indexed _user, uint _amount);\n\n    event OverstayPenaltyClaimed(address claimant, uint claimantReward, address depositor, uint remainder);\n\n    // --- Functions ---\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _priceFeedAddress,\n        address _LUSDAddress,\n        address _stabilityPoolAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress\n    ) external;\n\n    function getActiveDebt() external view returns (uint);\n    \n    function getActiveColl() external view returns (uint);\n    \n    function getClosedDebt() external view returns (uint);\n    \n    function getLiquidatedColl() external view returns (uint);\n\n    function getStabilityPoolLUSD() external view returns (uint);\n\n    function getCurrentETHGain(address _user) external view returns (uint);\n\n    function addColl() external payable;\n\n    function withdrawColl(address _account, uint _ETH) external;\n\n    function withdrawLUSD(address _account, uint _LUSD) external;\n    \n    function repayLUSD(address _account, uint _LUSD) external;\n\n    function lockLUSDGasCompensation(uint _LUSD) external;\n\n    function refundLUSDGasCompensation(uint _LUSD) external;\n\n    function sendLUSDGasCompensation(address _user, uint _LUSD) external;\n\n    function liquidate(uint _LUSD, uint _ETH) external;\n  \n    function movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) external;\n\n    function redeemCollateral(address _account, uint _LUSD, uint _ETH) external;\n\n    function redeemCloseTrove(address _account, uint _LUSD, uint _ETH) external;\n\n    // --- StabilityPool Functions ---\n    function provideToSP(uint _amount) external;\n\n    function withdrawFromSP(uint _amount) external;\n\n    function withdrawFromSPtoCDP(address _user, address _hint) external;\n\n    function offset(uint _debt, uint _coll) external;\n}\n"
    },
    "contracts/Dependencies/LiquityBase.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./Math.sol\";\n\n/* Base contract for TroveManager and BorrowerOperations. Contains global system constants and\ncommon functions. */\ncontract LiquityBase {\n    using SafeMath for uint;\n\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint constant public MCR = 1100000000000000000; // 110%\n\n    // Minimum collateral ratio for individual troves\n    uint constant public R_MCR = 3000000000000000000; // 300%\n\n    // Critical system collateral ratio. If the total system collateral (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint constant public  CCR = 1500000000000000000; // 150%\n\n    // Amount of LUSD to be locked in gas pool on opening troves\n    uint constant public LUSD_GAS_COMPENSATION = 10e18;\n\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 equals to applying 0.5%\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (actual debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\n        return _debt.add(LUSD_GAS_COMPENSATION);\n    }\n\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\n        return _debt.sub(LUSD_GAS_COMPENSATION);\n    }\n\n    /* Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\n    Given by the dollar value of 0.5% of collateral */\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n}\n"
    },
    "contracts/Dependencies/Math.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./SafeMath.sol\";\nimport \"./console.sol\";\n\nlibrary Math {\n    using SafeMath for uint;\n\n    // The virtual debt assigned to all troves.  Needed for preserving collateral for\n    uint constant virtualDebt = 6e18;\n  \n    function _min(uint _a, uint _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /* Converts the magnitude of an int to a uint\n    TODO:  check validity for num in region (num > 2**255) or (num < -(2**255) ) */\n    function _intToUint(int _num) internal pure returns (uint) {\n        return (_num >= 0) ? uint(_num) : uint(-_num); \n    }\n\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n    }\n\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the CDP has a debt of 0\n        else if (_debt == 0) {\n            return 2**256 - 1; \n        }\n    }\n\n}\n\n"
    },
    "contracts/TroveManager.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IPool.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Interfaces/IPoolManager.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPoolManager public poolManager;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    IStabilityPool public stabilityPool;\n\n    // A doubly linked list of CDPs, sorted by their collateral ratios\n    ISortedCDPs public sortedCDPs;\n\n    // --- Data structures ---\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a Collateralized Debt Position (CDP)\n    struct CDP {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => CDP) public CDPs;\n\n    uint public totalStakes;\n\n    // snapshot of the value of totalStakes immediately after the last liquidation\n    uint public totalStakesSnapshot;\n\n    // snapshot of the total collateral in ActivePool and DefaultPool, immediately after the last liquidation.\n    uint public totalCollateralSnapshot;\n\n    /* L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During it's lifetime, each stake earns:\n\n    An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    A LUSDDebt gain  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n\n    Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active CDP taken at the instant the stake was made */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active CDPs to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active CDP\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active CDP addresses - used to compute “approx hint” for list insertion\n    address[] public CDPOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* --- Variable container structs for liquidations ---\n\n    These structs are used to hold, return and assign variables inside the liquidation functions,\n    in order to avoid the error: \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInPool; \n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LocalVariables_BatchLiquidation {\n        uint price;\n        uint remainingLUSDInPool;\n        uint ICR;\n        bool recoveryModeAtStart;\n        bool backToNormalMode;\n    }\n\n    struct LiquidationValues {\n        uint entireCDPDebt;\n        uint entireCDPColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        \n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDtoRedeem;\n        uint totalETHtoSend;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event PoolManagerAddressChanged(address _newPoolManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n    event SizeListAddressChanged(uint _sizeRange, address _sizeListAddress);\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event CDPCreated(address indexed _user, uint arrayIndex);\n    event CDPUpdated(address indexed _user, uint _debt, uint _coll, uint stake, TroveManagerOperation operation);\n    event CDPLiquidated(address indexed _user, uint _debt, uint _coll, TroveManagerOperation operation);\n\n    // --- Modifiers ---\n\n    modifier onlyBorrowerOperations() {\n        require(_msgSender() == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n        _;\n    }\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _poolManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedCDPsAddress\n    )\n        external\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        poolManager = IPoolManager(_poolManagerAddress);\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedCDPsAddressChanged(_sortedCDPsAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getCDPOwnersCount() external view returns (uint) {\n        return CDPOwners.length;\n    }\n\n    function getTroveFromCDPOwnersArray(uint _index) external view returns (address) {\n        return CDPOwners[_index];\n    }\n\n    // --- CDP Liquidation functions ---\n\n    /* Single liquidation function. Closes the CDP of the specified user if its individual \n    collateral ratio is lower than the minimum collateral ratio. */\n    function liquidate(address _user) external {\n        _requireCDPisActive(_user);\n\n        address[] memory users = new address[](1);\n        users[0] = _user;\n        batchLiquidateTroves(users);\n    }\n\n    // --- Inner liquidation functions ---\n\n    function _liquidateNormalMode(address _user, uint _ICR, uint _LUSDInPool) internal\n    returns (LiquidationValues memory V)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        // If ICR >= MCR, or is last trove, don't liquidate\n        if (_ICR >= MCR || CDPOwners.length <= 1) {return V;}\n\n        (V.entireCDPDebt,\n        V.entireCDPColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = _getEntireDebtAndColl(_user);\n\n        poolManager.movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_user);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireCDPColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireCDPColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireCDPDebt, collToLiquidate, _LUSDInPool);\n\n        _closeCDP(_user);\n        emit CDPLiquidated(_user, V.entireCDPDebt, V.entireCDPColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    function _liquidateRecoveryMode(address _user, uint _ICR, uint _LUSDInPool) internal\n    returns (LiquidationValues memory V)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        // If is last trove, don't liquidate\n        if (CDPOwners.length <= 1) {return V;}\n\n        (V.entireCDPDebt,\n        V.entireCDPColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = _getEntireDebtAndColl(_user);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireCDPColl);\n        // in case of partial, it will be overriden to zero below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireCDPColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the CDP across all active CDPs\n        if (_ICR <= _100pct) {\n            poolManager.movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n            _removeStake(_user);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireCDPDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeCDP(_user);\n            emit CDPLiquidated(_user, V.entireCDPDebt, V.entireCDPColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // if 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            poolManager.movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n            _removeStake(_user);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireCDPDebt, L.collToLiquidate, _LUSDInPool);\n\n            _closeCDP(_user);\n            emit CDPLiquidated(_user, V.entireCDPDebt, V.entireCDPColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* If 110% <= ICR < 150% and there is LUSD in the Stability Pool, \n        only offset it as much as possible (no redistribution) */\n        } else if ((_ICR >= MCR) && (_ICR < CCR)) {\n            if (_LUSDInPool == 0) {\n                LiquidationValues memory zeroVals;\n                return zeroVals;\n            }\n            _applyPendingRewards(_user);\n            _removeStake(_user);\n\n            V = _getPartialOffsetVals(_user, V.entireCDPDebt, V.entireCDPColl, _LUSDInPool);\n\n            _closeCDP(_user);\n        } \n\n        else if (_ICR >= CCR) {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    function _getOffsetAndRedistributionVals(uint _debt, uint _coll, uint _LUSDInPool) internal pure\n    returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n         // Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        if (_LUSDInPool > 0) {\n        /* If the debt is larger than the deposited LUSD, offset an amount of debt equal to the latter,\n        and send collateral in proportion to the cancelled debt */\n            debtToOffset = Math._min(_debt, _LUSDInPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    function _getPartialOffsetVals(address _user, uint _entireCDPDebt, uint _entireCDPColl, uint _LUSDInPool) internal\n    returns\n    (LiquidationValues memory V) {\n\n        V.entireCDPDebt = _entireCDPDebt;\n        V.entireCDPColl = _entireCDPColl;\n\n        // When Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireCDPDebt <= _LUSDInPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireCDPColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireCDPDebt;\n            V.collToSendToSP = _entireCDPColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit CDPLiquidated(_user, _entireCDPDebt, _entireCDPColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* When trove's debt is greater than the Pool, perform a partial liquidation:\n        offset as much as possible, and do not redistribute the remainder.\n        Gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. */\n        else if (_entireCDPDebt > _LUSDInPool) {\n            // Partially liquidated pool can’t fall under gas compensation amount of debt\n            V.partialNewDebt = Math._max(_entireCDPDebt.sub(_LUSDInPool), LUSD_GAS_COMPENSATION);\n            // V.partialNewDebt >= _entireCDPDebt - _LUSDInPool =>\n            // _entireCDPDebt - V.partialNewDebt <= _entireCDPDebt - (_entireCDPDebt - _LUSDInPool) =>\n            // _entireCDPDebt - V.partialNewDebt <= _LUSDInPool =>\n            // V.debtToOffset <= _LUSDInPool\n            V.debtToOffset = _entireCDPDebt.sub(V.partialNewDebt);\n            uint collFraction = _entireCDPColl.mul(V.debtToOffset).div(_entireCDPDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n            // LUSD gas compensation remains untouched, so minimum debt rests assured\n            V.LUSDGasCompensation = 0;\n            \n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _user;\n            V.partialNewColl = _entireCDPColl.sub(collFraction);\n        }\n    }\n\n    /* Liquidate a sequence of troves. Closes a maximum number of n under-collateralized CDPs, \n    starting from the one with the lowest collateral ratio in the system */\n    function liquidateCDPs(uint _n) external {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = _checkRecoveryMode();\n     \n        // Perform the appropriate liquidation sequence - tally values and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromLiquidationSequence_RecoveryMode(L.price, L.LUSDInPool, _n);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromLiquidationSequence_NormalMode(L.price, L.LUSDInPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        poolManager.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr,\n                                        T.partialNewDebt,\n                                        T.partialNewColl,\n                                        L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        address payable msgSender = _msgSender();\n        // Send LUSD gas compensation to caller\n        if (T.totalLUSDGasCompensation > 0) {\n            poolManager.sendLUSDGasCompensation(msgSender, T.totalLUSDGasCompensation);\n        }\n\n        // Send ETH gas compensation to caller\n        activePool.sendETH(msgSender, T.totalCollGasCompensation);\n    }\n\n    function _getTotalFromLiquidationSequence_RecoveryMode(uint _price, uint _LUSDInPool, uint _n) internal \n    returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInPool = _LUSDInPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedCDPs.getLast();\n            L.ICR = _getCurrentICR(L.user, _price);\n\n            // Attempt to close CDP\n            if (L.backToNormalMode == false) {\n\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInPool == 0) {break;}\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInPool);\n\n                // Update aggregate trackers\n                L.remainingLUSDInPool = L.remainingLUSDInPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.ICR, L.remainingLUSDInPool);\n\n                L.remainingLUSDInPool = L.remainingLUSDInPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a CDP with ICR >= MCR\n\n            // Break the loop if it reaches the first CDP in the sorted list\n            if (L.user == sortedCDPs.getFirst()) {break;}\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidationSequence_NormalMode(uint _price, uint _LUSDInPool, uint _n) internal \n    returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInPool = _LUSDInPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedCDPs.getLast();\n            L.ICR = _getCurrentICR(L.user, _price);\n            \n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.ICR, L.remainingLUSDInPool);\n\n                L.remainingLUSDInPool = L.remainingLUSDInPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a CDP with ICR >= MCR\n            \n            // Break the loop if it reaches the first CDP in the sorted list\n            if (L.user == sortedCDPs.getFirst()) {break;}\n            L.i++;\n        }\n    }\n\n    /* Attempt to liquidate a custom set of troves provided by the caller.  Stops if a partial liquidation is \n    performed, and thus leaves optimization of the order troves up to the caller.  */\n    function batchLiquidateTroves(address[] memory _troveArray) public {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n        \n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = _checkRecoveryMode();\n        \n        // Perform the appropriate liquidation sequence - tally values and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInPool, _troveArray);\n        } else if (L.recoveryModeAtStart == false) {\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        poolManager.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr,\n                                        T.partialNewDebt,\n                                        T.partialNewColl,\n                                        L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        address payable msgSender = _msgSender();\n        // Send LUSD gas compensation to caller\n        if (T.totalLUSDGasCompensation > 0) {\n            poolManager.sendLUSDGasCompensation(msgSender, T.totalLUSDGasCompensation);\n        }\n        // Send ETH gas compensation to caller\n        activePool.sendETH(msgSender, T.totalCollGasCompensation);\n    }\n\n    function _getTotalFromBatchLiquidate_RecoveryMode(uint _price, uint _LUSDInPool, address[] memory _troveArray) internal \n    returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n        uint troveArrayLength = _troveArray.length;\n\n        L.remainingLUSDInPool = _LUSDInPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n         for (L.i = 0; L.i < troveArrayLength; L.i++) {\n             L.user = _troveArray[L.i];\n\n            L.ICR = _getCurrentICR(L.user, _price);\n\n            // Attempt to close trove\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInPool == 0) {continue;}\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInPool);\n\n                // Update aggregate trackers\n                L.remainingLUSDInPool = L.remainingLUSDInPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.ICR, L.remainingLUSDInPool);\n                L.remainingLUSDInPool = L.remainingLUSDInPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }  \n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(uint _price, uint _LUSDInPool, address[] memory _troveArray) internal \n    returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n        uint troveArrayLength = _troveArray.length;\n\n        L.remainingLUSDInPool = _LUSDInPool;\n        \n        for (L.i = 0; L.i < troveArrayLength; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = _getCurrentICR(L.user, _price);\n            \n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.ICR, L.remainingLUSDInPool);\n                L.remainingLUSDInPool = L.remainingLUSDInPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    } \n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V) \n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally gas compensation\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n\n        // Tally the total initial debt and coll of troves impacted by the sequence\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireCDPDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireCDPColl);\n\n        // Tally the debt and coll to offset and redistribute\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute =T1.totalCollToRedistribute .add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove and debt/coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n\n        return T2;\n    }\n\n    // Update coll, debt, stake and snapshot of partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove(address _user, uint _newDebt, uint _newColl, uint _price) internal {\n        if ( _user == address(0)) { return; }\n\n        CDPs[_user].debt = _newDebt;\n        CDPs[_user].coll = _newColl;\n        CDPs[_user].status = Status.active;\n    \n        _updateCDPRewardSnapshots(_user);\n        _updateStakeAndTotalStakes(_user);\n        \n        uint ICR = _getCurrentICR(_user, _price);\n\n        // Insert to sorted list and add to CDPOwners array\n        sortedCDPs.insert(_user, ICR, _price, _user, _user);\n        _addCDPOwnerToArray(_user);\n        \n        emit CDPUpdated(_user, _newDebt, _newColl, CDPs[_user].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _cdpUser's CDP in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromCDP(\n        address _cdpUser,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the CDP minus the gas compensation\n        V.LUSDLot = Math._min(_maxLUSDamount, CDPs[_cdpUser].debt.sub(LUSD_GAS_COMPENSATION));\n        \n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n        \n        // Decrease the debt and collateral of the current CDP according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (CDPs[_cdpUser].debt).sub(V.LUSDLot);\n        uint newColl = (CDPs[_cdpUser].coll).sub(V.ETHLot);\n\n        // V.LUSDLot <= CDPs[_cdpUser].debt - LUSD_GAS_COMPENSATION =>\n        // newDebt = CDPs[_cdpUser].debt - V.LUSDLot >=\n        //  >= CDPs[_cdpUser].debt - (CDPs[_cdpUser].debt - LUSD_GAS_COMPENSATION) =>\n        //  newDebt >= LUSD_GAS_COMPENSATION\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the CDP (except for the gas compensation), therefore the trove is closed\n            _removeStake(_cdpUser);\n            _closeCDP(_cdpUser);\n            poolManager.redeemCloseTrove(_cdpUser, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = Math._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedCDPs.reInsert(_cdpUser, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            CDPs[_cdpUser].debt = newDebt;\n            CDPs[_cdpUser].coll = newColl;\n            _updateStakeAndTotalStakes(_cdpUser);\n        }\n\n\n        emit CDPUpdated(\n                        _cdpUser,\n                        newDebt,\n                        newColl,\n                        CDPs[_cdpUser].stake,\n                        TroveManagerOperation.redeemCollateral\n                        ); \n\n        return V;\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedCDPs.contains(_firstRedemptionHint) ||\n            _getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextCDP = sortedCDPs.getNext(_firstRedemptionHint);\n        return nextCDP == address(0) || _getCurrentICR(nextCDP, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many CDPs as are needed to fill the redemption\n     request.  Applies pending rewards to a CDP before reducing its debt and coll.\n\n    Note that if _amount is very large, this function can run out of gas. This can be easily avoided by splitting the total _amount\n    in appropriate chunks and calling the function multiple times.\n\n    All CDPs that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed\n    If the last CDP does have some remaining debt, the reinsertion could be anywhere in the\n    list, therefore it requires a hint. A frontend should use getRedemptionHints() to calculate what the ICR of this CDP will be\n    after redemption, and pass a hint for its position in the sortedCDPs list along with the ICR value that the hint was found for.\n\n    If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    is very likely that the last (partially) redeemed CDP would end up with a different ICR than what the hint is for. In this case the\n    redemption will stop after the last completely redeemed CDP and the sender will keep the remaining LUSD amount, which they can attempt\n    to redeem later.\n     */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n    external\n    {\n        address redeemer = _msgSender();\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireLUSDBalanceCoversRedemption(redeemer, _LUSDamount);\n        \n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(redeemer) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentCDPuser;\n\n        // TODO: This is to jump into the first non undercollaterallized trove, right?\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentCDPuser = _firstRedemptionHint;\n        } else {\n            currentCDPuser = sortedCDPs.getLast();\n\n            while (currentCDPuser != address(0) && _getCurrentICR(currentCDPuser, price) < MCR) {\n                currentCDPuser = sortedCDPs.getPrev(currentCDPuser);\n            }\n        }\n\n        // Loop through the CDPs starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        while (currentCDPuser != address(0) && remainingLUSD > 0) {\n            // Save the address of the CDP preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedCDPs.getPrev(currentCDPuser);\n\n            _applyPendingRewards(currentCDPuser);\n\n            SingleRedemptionValues memory V = _redeemCollateralFromCDP(\n                currentCDPuser,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last CDP\n\n            T.totalLUSDtoRedeem  = T.totalLUSDtoRedeem.add(V.LUSDLot);\n            T.totalETHtoSend = T.totalETHtoSend.add(V.ETHLot);\n            \n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentCDPuser = nextUserToCheck;\n        }\n\n        // Burn the total LUSD redeemed from troves, and send the corresponding ETH to _msgSender()\n        poolManager.redeemCollateral(_msgSender(), T.totalLUSDtoRedeem, T.totalETHtoSend);\n\n        emit Redemption(_LUSDamount, T.totalLUSDtoRedeem, T.totalETHtoSend);\n    }\n\n    // --- Helper functions ---\n\n    function getCurrentICR(address _user, uint _price) external view returns (uint) {\n        return _getCurrentICR(_user, _price);\n    }\n\n    // Return the current collateral ratio (ICR) of a given CDP. Takes pending coll/debt rewards into account.\n    function _getCurrentICR(address _user, uint _price) internal view returns (uint) {\n        uint pendingETHReward = _computePendingETHReward(_user); \n        uint pendingLUSDDebtReward = _computePendingLUSDDebtReward(_user); \n        \n        uint currentETH = CDPs[_user].coll.add(pendingETHReward); \n        uint currentLUSDDebt = CDPs[_user].debt.add(pendingLUSDDebtReward); \n\n        uint ICR = Math._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _user) external onlyBorrowerOperations {\n        return _applyPendingRewards(_user);\n    }\n\n    // Add the user's coll and debt rewards earned from liquidations, to their CDP\n    function _applyPendingRewards(address _user) internal {\n        if (_hasPendingRewards(_user)) { \n        \n            _requireCDPisActive(_user);\n\n            // Compute pending rewards\n            uint pendingETHReward = _computePendingETHReward(_user); \n            uint pendingLUSDDebtReward = _computePendingLUSDDebtReward(_user);  \n\n            // Apply pending rewards to trove's state\n            CDPs[_user].coll = CDPs[_user].coll.add(pendingETHReward);  \n            CDPs[_user].debt = CDPs[_user].debt.add(pendingLUSDDebtReward); \n\n            _updateCDPRewardSnapshots(_user);\n\n            // Tell PM to transfer from DefaultPool to ActivePool\n            poolManager.movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit CDPUpdated(_user, CDPs[_user].debt, CDPs[_user].coll, CDPs[_user].stake, TroveManagerOperation.applyPendingRewards);\n        }\n    }\n\n    // Update user's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateCDPRewardSnapshots(address _user) external onlyBorrowerOperations {\n       return  _updateCDPRewardSnapshots(_user);\n    }\n\n    function _updateCDPRewardSnapshots(address _user) internal {\n        rewardSnapshots[_user].ETH = L_ETH; \n        rewardSnapshots[_user].LUSDDebt = L_LUSDDebt; \n    }\n    \n    function getPendingETHReward(address _user) external view returns (uint) {\n        return _computePendingETHReward(_user);\n    }\n\n    // Get the user's pending accumulated ETH reward, earned by its stake\n    function _computePendingETHReward(address _user) internal view returns (uint) {\n        uint snapshotETH = rewardSnapshots[_user].ETH; \n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH); \n        \n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n       \n        uint stake = CDPs[_user].stake;\n        \n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n    function getPendingLUSDDebtReward(address _user) external view returns (uint) {\n        return _computePendingLUSDDebtReward(_user);\n    }\n\n     // Get the user's pending accumulated LUSD reward, earned by its stake\n    function _computePendingLUSDDebtReward(address _user) internal view returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_user].LUSDDebt;  \n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt); \n       \n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n       \n        uint stake =  CDPs[_user].stake; \n      \n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n     \n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _user) public view returns (bool) {\n        require(uint(CDPs[_user].status) == 1, \"TroveManager: User does not have an active trove\");\n        return _hasPendingRewards(_user);\n    }\n    \n    function _hasPendingRewards(address _user) internal view returns (bool) {\n        /* A CDP has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        pending rewards */\n        return (rewardSnapshots[_user].ETH < L_ETH);\n    }\n\n     // Returns the CDPs entire debt and coll, including distribution pending rewards.\n    function _getEntireDebtAndColl(address _user) \n    internal view\n    returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = CDPs[_user].debt;\n        coll = CDPs[_user].coll;\n\n        pendingLUSDDebtReward = _computePendingLUSDDebtReward(_user);\n        pendingETHReward = _computePendingETHReward(_user);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _user) external onlyBorrowerOperations {\n        return _removeStake(_user);\n    }\n\n    // Remove use's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _user) internal {\n        uint stake = CDPs[_user].stake;\n        totalStakes = totalStakes.sub(stake);\n        CDPs[_user].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _user) external onlyBorrowerOperations returns (uint) {\n        return _updateStakeAndTotalStakes(_user);\n    }\n\n    // Update user's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _user) internal returns (uint) {\n        uint newStake = _computeNewStake(CDPs[_user].coll); \n        uint oldStake = CDPs[_user].stake;\n        CDPs[_user].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    /* Calculate a new stake based on the snapshots of the totalStakes and totalCollateral  \n    taken at the last liquidation */\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /* The following condition holds true for 2 reasons:\n             * Because don’t allow to close or liquidate the last trove.\n             * Because when we close or liquidate a trove, we redistribute the pending rewards,\n             * so if all troves were closed/liquidated, rewards would’ve been emptied\n             * and totalCollateralSnapshot would be zero too.\n             */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n        \n        if (totalStakes > 0) {\n            /* Add distributed coll and debt rewards-per-unit-staked to the running totals. \n            Division uses error correction. */\n            uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n            uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n            uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n            uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n            lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n            lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n            L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n            L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n        }\n        // Transfer coll and debt from ActivePool to DefaultPool\n        poolManager.liquidate(_debt, _coll);\n    }\n\n    function closeCDP(address _user) external onlyBorrowerOperations {\n        return _closeCDP(_user);\n    }\n\n    function _closeCDP(address _user) internal {\n        uint CDPOwnersArrayLength = CDPOwners.length;\n        _requireMoreThanOneTroveInSystem(CDPOwnersArrayLength);\n        \n        CDPs[_user].status = Status.closed;\n        CDPs[_user].coll = 0;\n        CDPs[_user].debt = 0;\n        \n        rewardSnapshots[_user].ETH = 0;\n        rewardSnapshots[_user].LUSDDebt = 0;\n \n        _removeCDPOwner(_user, CDPOwnersArrayLength);\n        sortedCDPs.remove(_user);\n    }\n\n    // Updates snapshots of system stakes and system collateral, excluding a given collateral remainder from the calculation\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n  \n    // Push the owner's address to the CDP owners list, and record the corresponding array index on the CDP struct\n    function addCDPOwnerToArray(address _user) external onlyBorrowerOperations returns (uint index) {\n        return _addCDPOwnerToArray(_user);\n    }\n\n    function _addCDPOwnerToArray(address _user) internal returns (uint128 index) {\n        require(CDPOwners.length < 2**128 - 1, \"TroveManager: CDPOwners array has maximum size of 2^128 - 1\");\n        \n        // Push the user to the array, and convert the returned length to index of the new element, as a uint128\n        index = uint128(CDPOwners.push(_user).sub(1));\n        CDPs[_user].arrayIndex = index;\n\n        return index;\n    }\n\n    /* Remove a CDP owner from the CDPOwners array, not preserving order. Removing owner 'B' does the following: \n    [A B C D E] => [A E C D], and updates E's CDP struct to point to its new array index. */\n    function _removeCDPOwner(address _user, uint CDPOwnersArrayLength) internal {\n        require(CDPs[_user].status == Status.closed, \"TroveManager: CDP is still active\");\n\n        uint128 index = CDPs[_user].arrayIndex;   \n        uint length = CDPOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast); \n\n        address addressToMove = CDPOwners[idxLast];\n       \n        CDPOwners[index] = addressToMove;   \n        CDPs[addressToMove].arrayIndex = index;   \n        CDPOwners.length--;  \n    }\n  \n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() external view returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n    /* Check whether or not the system *would be* in Recovery Mode, \n    given an ETH:USD price, and total system coll and debt. */\n    function _checkPotentialRecoveryMode(uint _entireSystemColl, uint _entireSystemDebt, uint _price) \n    internal \n    pure returns (bool) \n    {\n        uint TCR = Math._computeCR(_entireSystemColl, _entireSystemDebt, _price); \n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function getTCR() external view returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        return _getTCR(price);\n    }\n\n    function _checkRecoveryMode() internal view returns (bool) {\n        uint price = priceFeed.getPrice();\n        uint TCR = _getTCR(price);\n        \n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _getTCR(uint _price) internal view returns (uint TCR) { \n        uint entireSystemColl = _getEntireSystemColl();\n        uint entireSystemDebt = _getEntireSystemDebt();\n\n        TCR = Math._computeCR(entireSystemColl, entireSystemDebt, _price); \n\n        return TCR;\n    }\n\n    function getEntireSystemColl() external view returns (uint entireSystemColl) {\n        return _getEntireSystemColl();\n    }\n\n    function _getEntireSystemColl() internal view returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);  \n    }\n\n    function getEntireSystemDebt() external view returns (uint entireSystemDebt) {\n        return _getEntireSystemDebt();\n    }\n\n    function _getEntireSystemDebt() internal view returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCDPisActive(address _user) internal view {\n        require(CDPs[_user].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _user, uint _amount) internal view {\n        require(lusdToken.balanceOf(_user) >= _amount, \"TroveManager: Requested redemption amount must be >= user's LUSD token balance\");\n    }\n\n    function _requireETHSentSuccessfully(bool _success) internal pure {\n        require(_success, \"TroveManager: Failed to send ETH to msg.sender\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint CDPOwnersArrayLength) internal view {\n        require (CDPOwnersArrayLength > 1 && sortedCDPs.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    // --- Trove property getters ---\n\n    function getCDPStatus(address _user) external view returns (uint) {\n        return uint(CDPs[_user].status);\n    }\n\n    function getCDPStake(address _user) external view returns (uint) {\n        return CDPs[_user].stake;\n    }\n\n    function getCDPDebt(address _user) external view returns (uint) {\n        return CDPs[_user].debt;\n    }\n\n    function getCDPColl(address _user) external view returns (uint) {\n        return CDPs[_user].coll;\n    }\n\n    // --- Trove property setters --- \n\n    function setCDPStatus(address _user, uint _num) external onlyBorrowerOperations {\n        CDPs[_user].status = Status(_num);\n    }\n\n    function increaseCDPColl(address _user, uint _collIncrease) external onlyBorrowerOperations returns (uint) {\n        uint newColl = CDPs[_user].coll.add(_collIncrease);\n        CDPs[_user].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseCDPColl(address _user, uint _collDecrease) external onlyBorrowerOperations returns (uint) {\n        uint newColl = CDPs[_user].coll.sub(_collDecrease);\n        CDPs[_user].coll = newColl;\n        return newColl;\n    }\n\n    function increaseCDPDebt(address _user, uint _debtIncrease) external onlyBorrowerOperations returns (uint) {\n        uint newDebt = CDPs[_user].debt.add(_debtIncrease);\n        CDPs[_user].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseCDPDebt(address _user, uint _debtDecrease) external onlyBorrowerOperations returns (uint) {\n        uint newDebt = CDPs[_user].debt.sub(_debtDecrease);\n        CDPs[_user].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface IStabilityPool {\n    // --- Events ---\n    event ETHBalanceUpdated(uint _newBalance);\n\n    event LUSDBalanceUpdated(uint _newBalance);\n\n    event PoolManagerAddressChanged(address _newAddress);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    function getETH() external view returns (uint);\n    \n    function getTotalLUSDDeposits() external view returns (uint);\n\n    function setAddresses(\n        address _poolManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function sendETH(address _account, uint _amount) external;\n\n    function increaseLUSD(uint _amount) external;\n\n    function decreaseLUSD(uint _amount) external;\n\n    function getRawETHBalance() external view returns (uint);\n}"
    },
    "contracts/Interfaces/ILUSDToken.sol": {
      "content": "pragma solidity >=0.5.16;\ninterface ILUSDToken { \n    // --- Events ---\n    event PoolManagerAddressChanged( address _newPoolManagerAddress);\n\n    event LUSDTokenBalanceUpdated(address _user, uint _amount);\n\n    // --- Functions ---\n    function setPoolManagerAddress(address _poolManagerAddress) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/LUSDToken.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Dependencies/IERC20.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract LUSDToken is IERC20, ILUSDToken, Ownable {\n    using SafeMath for uint256;\n\n    string constant internal NAME = \"LUSD\";\n    string constant internal SYMBOL = \"LUSD\";\n    uint8 constant internal DECIMALS = 18;\n\n    // User data for LUSD token\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    address public poolManagerAddress;\n\n    uint256 public _totalSupply;\n\n    // --- Events ---\n\n    event PoolManagerAddressChanged( address _newPoolManagerAddress);\n    event LUSDTokenBalanceUpdated(address _user, uint _amount);\n\n    // --- Modifiers ---\n    \n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"LUSDToken: Caller is not the PoolManager\");\n        _;\n    }\n\n    // --- Functions ---\n\n    function setPoolManagerAddress(address _poolManagerAddress) external onlyOwner {\n        poolManagerAddress =  _poolManagerAddress;\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n\n        _renounceOwnership();\n    }\n\n    function mint(address _account, uint256 _amount) external onlyPoolManager {\n        _mint(_account, _amount); \n    }\n    \n    function burn(address _account, uint256 _amount) external onlyPoolManager {\n        _burn(_account, _amount); \n    }\n    \n    function sendToPool(address _sender,  address _poolAddress, uint256 _amount) external onlyPoolManager {\n        _transfer(_sender, _poolAddress, _amount);\n    }\n    \n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount ) external onlyPoolManager {\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- Balance functions ---\n\n    function getBalance(address _account) external view returns (uint) {\n        return balanceOf(_account);\n    }\n\n    function _addToBalance(address _account, uint256 _value) internal {\n        balances[_account] = balances[_account].add(_value);\n    }\n\n    function _subFromBalance(address _account, uint256 _value) internal {\n        balances[_account] = balances[_account].sub(_value, 'ERC20: subtracted amount exceeds balance');\n    }\n\n    // --- Allowance functions ---\n\n    function getAllowance(address _owner, address _spender) public view returns (uint) {\n        return allowances[_owner][_spender];\n    }\n\n    // --- OPENZEPPELIN ERC20 FUNCTIONALITY ---\n\n   /**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\n   \n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return getAllowance(owner, spender);\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint newAllowance = getAllowance(sender, _msgSender()).sub(amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), newAllowance);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        uint newAllowance = getAllowance(_msgSender(),spender).add(addedValue);\n        _approve(_msgSender(), spender, newAllowance);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint newAllowance = getAllowance(_msgSender(), spender).sub(subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, newAllowance);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _subFromBalance(sender, amount);\n        _addToBalance(recipient, amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _addToBalance(account, amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");  \n        _subFromBalance(account, amount);\n        \n        _totalSupply = _totalSupply.sub(amount);  \n\n        emit Transfer(account, address(0), amount); \n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- Optional functions ---\n\n    function name() external view returns (string memory) {\n        return NAME;\n    }\n\n    function symbol() external view returns (string memory) {\n        return SYMBOL;\n    }\n\n    function decimals() external view returns (uint8) {\n        return DECIMALS;\n    }\n}\n"
    },
    "contracts/Dependencies/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/DefaultPool.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport './Interfaces/IPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract DefaultPool is Ownable, IPool {\n    using SafeMath for uint256;\n\n    address public poolManagerAddress;\n    address public activePoolAddress;\n    uint256 internal ETH;  // deposited ether tracker\n    uint256 internal LUSDDebt;  // total outstanding CDP debt\n\n    // --- Modifiers ---\n\n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"DefaultPool:  Caller is not the PoolManager\");\n        _;\n    }\n\n    modifier onlyActivePool {\n        require(_msgSender() == activePoolAddress, \"DefaultPool: Caller is not ActivePool\");\n        _;\n    }\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _poolManagerAddress,\n        address _activePoolAddress\n    )\n        external\n        onlyOwner\n    {\n        poolManagerAddress = _poolManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view returns (uint) {\n        return ETH;\n    }\n\n    function getLUSDDebt() external view returns (uint) {\n        return LUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) external onlyPoolManager {\n        ETH = ETH.sub(_amount); \n         emit EtherSent(_account, _amount);  \n\n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \n        require(success, \"DefaultPool: sending ETH failed\");     \n    }\n\n    function increaseLUSDDebt(uint _amount) external onlyPoolManager {\n        LUSDDebt = LUSDDebt.add(_amount);\n    }\n\n    function decreaseLUSDDebt(uint _amount) external onlyPoolManager {\n        LUSDDebt = LUSDDebt.sub(_amount); \n    }\n\n    /* Returns the raw ether balance at DefaultPool address.  \n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\n    function getRawETHBalance() external view returns (uint) {\n        return address(this).balance;\n    }\n\n    function () external payable onlyActivePool {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/Dependencies/SafeMath128.sol": {
      "content": "pragma solidity 0.5.16;\n\n// Safemath functions for overflow protection on uint128 basic arithmetic operations.\n\nlibrary SafeMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c = a + b;\n        require(c >= a, \"SafeMath128: addition overflow\");\n\n        return c;\n    }\n   \n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b <= a, \"SafeMath128: subtraction overflow\");\n        uint128 c = a - b;\n\n        return c;\n    }\n}"
    },
    "contracts/HintHelpers.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\n\ncontract HintHelpers is LiquityBase, Ownable {\n\n    IPriceFeed public priceFeed;\n\n    ISortedCDPs public sortedCDPs;\n\n    ITroveManager public troveManager;\n\n    // --- Events ---\n\n    event PriceFeedAddressChanged(address _priceFeedAddress);\n    event SortedCDPsAddressChanged(address _sortedCDPsAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _priceFeedAddress,\n        address _sortedCDPsAddress,\n        address _troveManagerAddress\n    )\n        external\n        onlyOwner\n    {\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedCDPsAddressChanged(_sortedCDPsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /* getRedemptionHints() - Helper function for redeemCollateral().\n     *\n     * Find the first and last CDPs that will modified by calling redeemCollateral() with the same _LUSDamount and _price,\n     * and return the address of the first one and the final ICR of the last one.\n     */\n    function getRedemptionHints(uint _LUSDamount, uint _price)\n        external\n        view\n        returns (address firstRedemptionHint, uint partialRedemptionHintICR)\n    {\n        uint remainingLUSD = _LUSDamount;\n        address currentCDPuser = sortedCDPs.getLast();\n\n        while (currentCDPuser != address(0) && troveManager.getCurrentICR(currentCDPuser, _price) < MCR) {\n            currentCDPuser = sortedCDPs.getPrev(currentCDPuser);\n        }\n\n        firstRedemptionHint = currentCDPuser;\n\n        while (currentCDPuser != address(0) && remainingLUSD > 0) {\n            uint LUSDDebt = _getNetDebt(troveManager.getCDPDebt(currentCDPuser))\n                                     .add(troveManager.getPendingLUSDDebtReward(currentCDPuser));\n\n            if (LUSDDebt > remainingLUSD) {\n                uint ETH = troveManager.getCDPColl(currentCDPuser)\n                                     .add(troveManager.getPendingETHReward(currentCDPuser));\n                uint newColl = ETH.sub(remainingLUSD.mul(1e18).div(_price));\n\n                uint newDebt = LUSDDebt.sub(remainingLUSD);\n                uint compositeDebt = _getCompositeDebt(newDebt);\n\n                partialRedemptionHintICR = Math._computeCR(newColl, compositeDebt, _price);\n\n                break;\n            } else {\n                remainingLUSD = remainingLUSD.sub(LUSDDebt);\n            }\n\n            currentCDPuser = sortedCDPs.getPrev(currentCDPuser);\n        }\n    }\n\n    /* getApproxHint() - return address of a CDP that is, on average, (length / numTrials) positions away in the \n    sortedCDPs list from the correct insert position of the CDP to be inserted. \n    \n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \n    be <= sqrt(length) positions away from the correct insert position.\n   \n    Note on the use of block.timestamp for random number generation: it is known to be gameable by miners. However, no value \n    transmission depends on getApproxHint() - it is only used to generate hints for efficient list traversal. In this case, \n    there is no profitable exploit.\n    */\n    function getApproxHint(uint _CR, uint _numTrials) external view returns (address) {\n        uint arrayLength = troveManager.getCDPOwnersCount();\n        if (arrayLength == 0 ) { return address(0); } \n\n        uint price = priceFeed.getPrice();\n        address hintAddress = sortedCDPs.getLast();\n        uint closestICR = troveManager.getCurrentICR(hintAddress, price);\n        uint diff = Math._getAbsoluteDifference(_CR, closestICR);\n        uint i = 1;\n\n        while (i < _numTrials) {\n            uint arrayIndex = _getRandomArrayIndex(block.timestamp.add(i), arrayLength);\n            address currentAddress = troveManager.getTroveFromCDPOwnersArray(arrayIndex);\n            uint currentICR = troveManager.getCurrentICR(currentAddress, price);\n\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n            uint currentDiff = Math._getAbsoluteDifference(currentICR, _CR);\n\n            if (currentDiff < diff) {\n                closestICR = currentICR;\n                diff = currentDiff;\n                hintAddress = currentAddress;\n            }\n            i++;\n        }\n        return hintAddress;\n    }\n\n    // Convert input to pseudo-random uint in range [0, arrayLength - 1]\n    function _getRandomArrayIndex(uint _input, uint _arrayLength) internal pure returns (uint) {\n        uint randomIndex = uint256(keccak256(abi.encodePacked(_input))) % (_arrayLength);\n        return randomIndex;\n   }\n\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return Math._computeCR(_coll, _debt, _price);\n    }\n}"
    },
    "contracts/Interfaces/AggregatorInterface.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface AggregatorInterface {\n    event AnswerUpdated(int256 indexed current,  uint256 indexed roundId, uint256 timestamp);\n\n    event NewRound(uint256 indexed roundId, address indexed startedBy);\n\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256); \n}"
    },
    "contracts/Interfaces/IDeployedAggregator.sol": {
      "content": "pragma solidity >=0.5.16;\n\n/* Interface for the mainnet deployed Chainlink aggregator reference contract. Differs from the aggregator interface\nin the Chainlink npm package */\ninterface IDeployedAggregator {\n  function latestCompletedAnswer() external view returns (uint256);\n  function currentAnswer() external view returns (int256);\n  function updatedHeight() external view returns (uint256);\n}"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/MultiCDPGetter.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedCDPs.sol\";\n\n/*  Helper contract for grabbing CDP data for the front end. Not part of the core Liquity system. */\ncontract MultiCDPGetter {\n    struct CombinedCDPData {\n        address owner;\n\n        uint debt;\n        uint coll;\n        uint stake;\n\n        uint snapshotETH;\n        uint snapshotLUSDDebt;\n    }\n\n    TroveManager public troveManager; // XXX CDPs missing from ITroveManager?\n    ISortedCDPs public sortedCDPs;\n\n    constructor(TroveManager _troveManager, ISortedCDPs _sortedCDPs) public {\n        troveManager = _troveManager;\n        sortedCDPs = _sortedCDPs;\n    }\n\n    function getMultipleSortedCDPs(int _startIdx, uint _count)\n        external view returns (CombinedCDPData[] memory _cdps)\n    {\n        uint startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint sortedCDPsSize = sortedCDPs.getSize();\n\n        if (startIdx >= sortedCDPsSize) {\n            _cdps = new CombinedCDPData[](0);\n        } else {\n            uint maxCount = sortedCDPsSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _cdps = _getMultipleSortedCDPsFromHead(startIdx, _count);\n            } else {\n                _cdps = _getMultipleSortedCDPsFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedCDPsFromHead(uint _startIdx, uint _count)\n        internal view returns (CombinedCDPData[] memory _cdps)\n    {\n        address currentCDPowner = sortedCDPs.getFirst();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentCDPowner = sortedCDPs.getNext(currentCDPowner);\n        }\n\n        _cdps = new CombinedCDPData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _cdps[idx].owner = currentCDPowner;\n            (\n                _cdps[idx].debt,\n                _cdps[idx].coll,\n                _cdps[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.CDPs(currentCDPowner);\n            (\n                _cdps[idx].snapshotETH,\n                _cdps[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentCDPowner);\n\n            currentCDPowner = sortedCDPs.getNext(currentCDPowner);\n        }\n    }\n\n    function _getMultipleSortedCDPsFromTail(uint _startIdx, uint _count)\n        internal view returns (CombinedCDPData[] memory _cdps)\n    {\n        address currentCDPowner = sortedCDPs.getLast();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentCDPowner = sortedCDPs.getPrev(currentCDPowner);\n        }\n\n        _cdps = new CombinedCDPData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _cdps[idx].owner = currentCDPowner;\n            (\n                _cdps[idx].debt,\n                _cdps[idx].coll,\n                _cdps[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.CDPs(currentCDPowner);\n            (\n                _cdps[idx].snapshotETH,\n                _cdps[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentCDPowner);\n\n            currentCDPowner = sortedCDPs.getPrev(currentCDPowner);\n        }\n    }\n}\n"
    },
    "contracts/SortedCDPs.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"./Interfaces/ISortedCDPs.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/* \nA sorted doubly linked list with nodes sorted in descending order.\n\nNodes map to active CDPs in the system - the ID property is the address of a CDP owner. \nNodes are ordered according to their current individual collateral ratio (ICR).\n\nThe list optionally accepts insert position hints.\n\nICRs are computed dynamically at runtime, and not stored on the Node. This is because ICRs of active CDPs \nchange dynamically as liquidation events occur.\n\nThe list relies on the fact that liquidation events preserve ordering: a liquidation decreases the ICRs of all active CDPs, \nbut maintains their order. A node inserted based on current ICR will maintain the correct position, \nrelative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\nThus, Nodes remain sorted by current ICR.\n\nNodes need only be re-inserted upon a CDP operation - when the owner adds or removes collateral or debt \nto their position.\n\nThe list is a modification of the following audited SortedDoublyLinkedList:\nhttps://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n\n\nChanges made in the Liquity implementation:\n\n- Keys have been removed from nodes\n\n- Ordering checks for insertion are performed by comparing an ICR argument to the current ICR, calculated at runtime. \nThe list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\n\n- Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n*/\ncontract SortedCDPs is Ownable, ISortedCDPs {\n    using SafeMath for uint256;\n\n    event TroveManagerAddressChanged(address _newCDPlManagerAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n    address public TroveManagerAddress;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId;                  // Id of next node (smaller ICR) in the list\n        address prevId;                  // Id of previous node (larger ICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head;                        // Head of the list. Also the node in the list with the largest ICR\n        address tail;                        // Tail of the list. Also the node in the list with the smallest ICR\n        uint256 maxSize;                     // Maximum size of the list\n        uint256 size;                        // Current size of the list\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Modifiers ---\n\n    modifier onlyBorrowerOperations() {\n        require(_msgSender() == borrowerOperationsAddress, \"SortedCDPs: Caller is not the BorrowerOperations contract\");\n        _;\n    }\n\n    modifier onlyTroveManager() {\n        require(_msgSender() == TroveManagerAddress, \"SortedCDPs: Caller is not the TroveManager\");\n        _;\n    }\n\n     modifier onlyBOorCDPM() {\n        address sender = _msgSender();\n        require(sender == borrowerOperationsAddress || sender == TroveManagerAddress, \n                \"SortedCDPs: Caller is neither BO nor CDPM\");\n        _;\n    }\n\n    // --- Dependency setters --- \n\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external onlyOwner {\n        require(_size > 0, \"SortedCDPs: Size can’t be zero\");\n\n        data.maxSize = _size;\n\n        TroveManagerAddress = _TroveManagerAddress;\n        troveManager = ITroveManager(_TroveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_TroveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        _renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert (address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) external onlyBOorCDPM {\n        _insert (_id, _ICR, _price, _prevId, _nextId);\n    }\n    \n    function _insert(address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) internal {\n        // List must not be full\n        require(!isFull());  \n        // List must not already contain node\n        require(!_contains(_id));  \n        // Node id must not be null\n        require(_id != address(0));  \n        // ICR must be non-zero\n        require(_ICR > 0); \n\n        address prevId = _prevId; \n        address nextId = _nextId; \n\n        if (!_validInsertPosition(_ICR, _price, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(_ICR, _price, prevId, nextId);   \n        }\n        \n         data.nodes[_id].exists = true;  \n    \n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id; \n            data.tail = _id; \n        } else if (prevId == address(0)) { \n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head; \n            data.nodes[data.head].prevId = _id;  \n            data.head = _id; \n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else { \n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId; \n            data.nodes[_id].prevId = prevId; \n            data.nodes[prevId].nextId = _id; \n            data.nodes[nextId].prevId = _id; \n        }\n\n        data.size = data.size.add(1); \n    }\n\n    function remove(address _id) external onlyTroveManager {\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(_contains(_id)); \n\n        if (data.size > 1) { \n            // List contains more than a single node\n            if (_id == data.head) { \n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId; \n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0); \n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id]; \n        data.size = data.size.sub(1); \n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new ICR\n     * @param _id Node's id\n     * @param _newICR Node's new ICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(address _id, uint256 _newICR, uint _price, address _prevId, address _nextId) external onlyBOorCDPM {\n        // List must contain the node\n        require(_contains(_id));\n\n        // Remove node from the list\n        _remove(_id);\n\n        if (_newICR > 0) {\n            // Insert node if it has a non-zero ICR\n            _insert(_id, _newICR, _price, _prevId, _nextId);\n        }\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     * @param _transcoder Address of transcoder\n     */\n    function contains(address _id) external view returns (bool) {\n       return _contains(_id);\n    }\n\n    function _contains(address _id) internal view returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest ICR)\n     */\n    function getFirst() external view returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest ICR)\n     */\n    function getLast() external view returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller ICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger ICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given ICR\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    \n    function validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) external view returns (bool) {\n        return _validInsertPosition(_ICR, _price, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return data.head == _nextId && _ICR >= troveManager.getCurrentICR(_nextId, _price);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return data.tail == _prevId && _ICR <= troveManager.getCurrentICR(_prevId, _price);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_ICR` falls between the two nodes' ICRs\n            return data.nodes[_prevId].nextId == _nextId && \n                   troveManager.getCurrentICR(_prevId, _price) >= _ICR && \n                   _ICR >= troveManager.getCurrentICR(_nextId, _price);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger ICRs to smaller ICRs) to find a valid insert position\n     * @param _ICR Node's ICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function descendList(uint256 _ICR, uint _price, address _startId) private view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (data.head == _startId && _ICR >= troveManager.getCurrentICR(_startId, _price)) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (prevId != address(0) && !_validInsertPosition(_ICR, _price, prevId, nextId)) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller ICRs to larger ICRs) to find a valid insert position\n     * @param _ICR Node's ICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function ascendList(uint256 _ICR, uint _price, address _startId) private view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (data.tail == _startId && _ICR <= troveManager.getCurrentICR(_startId, _price)) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (nextId != address(0) && !_validInsertPosition(_ICR, _price, prevId, nextId)) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given ICR\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) external view returns (address, address) {\n        return _findInsertPosition(_ICR, _price, _prevId, _nextId);\n    }\n\n    function _findInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (!_contains(prevId) || _ICR > troveManager.getCurrentICR(prevId, _price)) {\n                // `prevId` does not exist anymore or now has a smaller ICR than the given ICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (!_contains(nextId) || _ICR < troveManager.getCurrentICR(nextId, _price)) {\n                // `nextId` does not exist anymore or now has a larger ICR than the given ICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return descendList(_ICR, _price, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return ascendList(_ICR, _price, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return descendList(_ICR, _price, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return descendList(_ICR, _price, prevId);\n        }\n    }\n}"
    },
    "contracts/PoolManager.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IPool.sol';\nimport './Interfaces/IPoolManager.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport './Interfaces/ILUSDToken.sol';\nimport './Dependencies/Math.sol';\nimport './Dependencies/SafeMath.sol';\nimport './Dependencies/SafeMath128.sol';\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n// PoolManager maintains all pools \ncontract PoolManager is Ownable, IPoolManager {\n    using SafeMath for uint;\n    using SafeMath128 for uint128;\n\n    address constant public GAS_POOL_ADDRESS = 0x00000000000000000000000000000000000009A5;\n\n    // --- Connected contract declarations ---\n\n    IBorrowerOperations public borrowerOperations;\n    address public borrowerOperationsAddress;\n\n    address public troveManagerAddress;\n    ITroveManager public troveManager;\n\n    IPriceFeed public priceFeed;\n\n    ILUSDToken public LUSD;\n\n    IStabilityPool public stabilityPool;\n    address public stabilityPoolAddress;\n\n    IPool public activePool;\n    address public activePoolAddress;\n\n    IPool public defaultPool;\n    address public defaultPoolAddress;\n   // --- Data structures ---\n   \n    mapping (address => uint) public initialDeposits;\n\n    struct Snapshot {\n        uint S;\n        uint P;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    /* Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit, \n    given a series of liquidations, each of which cancel some LUSD debt with the deposit. \n\n    During its lifetime, a deposit's value evolves from d(0) to (d(0) * P / P(0) ), where P(0) \n    is the snapshot of P taken at the instant the deposit was made. 18 DP decimal.  */\n    uint public P = 1e18;\n\n     // Each time the scale of P shifts by 1e18, the scale is incremented by 1\n    uint128 public currentScale; \n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;  \n\n    /* ETH Gain sum 'S': During it's lifetime, each deposit d(0) earns an ETH gain of ( d(0) * [S - S(0)] )/P(0), where S(0) \n    is the snapshot of S taken at the instant the deposit was made.\n   \n    The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n\n    - The inner mapping records the sum S at different scales\n    - The outer mapping records the (scale => sum) mappings, for different epochs. */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToSum;\n\n    // Map users to their individual snapshot structs\n    mapping (address => Snapshot) public snapshot;\n\n    // Error trackers for the error correction in the offset calculation\n    uint public lastETHError_Offset;\n    uint public lastLUSDLossError_Offset;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event UserSnapshotUpdated(uint _P, uint _S);\n    event P_Updated(uint _P);\n    event S_Updated(uint _S);\n    event UserDepositChanged(address indexed _user, uint _amount);\n    event ETHGainWithdrawn(address indexed _user, uint _ETH, uint _LUSDLoss);\n\n    // --- Modifiers ---\n\n    modifier onlyTroveManager() {\n        require(_msgSender() == troveManagerAddress, \"PoolManager: Caller is not the TroveManager\");\n        _;\n    }\n\n     modifier onlyBorrowerOperations() {\n        require(_msgSender() == borrowerOperationsAddress, \"PoolManager: Caller is not the BorrowerOperations contract\");\n        _;\n    }\n\n    modifier onlyStabilityPool {\n        require(\n            _msgSender() == stabilityPoolAddress,\n            \"PoolManager: Caller is not StabilityPool\");\n        _;\n    }\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _priceFeedAddress,\n        address _LUSDAddress,\n        address _stabilityPoolAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress\n    )\n    external\n    onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManagerAddress = _troveManagerAddress;\n        troveManager = ITroveManager(_troveManagerAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        LUSD = ILUSDToken(_LUSDAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        activePoolAddress = _activePoolAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPoolAddress = _defaultPoolAddress;\n        defaultPool = IPool(_defaultPoolAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_LUSDAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    // Return the total active debt (in LUSD) in the system\n    function getActiveDebt() external view returns (uint) {\n        return activePool.getLUSDDebt();\n    }    \n    \n    // Return the total active collateral (in ETH) in the system\n    function getActiveColl() external view returns (uint) {\n        return activePool.getETH();\n    } \n    \n    // Return the amount of closed debt (in LUSD)\n    function getClosedDebt() external view returns (uint) {\n        return defaultPool.getLUSDDebt();\n    }    \n    \n    // Return the amount of closed collateral (in ETH)\n    function getLiquidatedColl() external view returns (uint) {\n        return defaultPool.getETH();\n    }\n    \n    // Return the total LUSD in the Stability Pool\n    function getStabilityPoolLUSD() external view returns (uint) {\n        return stabilityPool.getTotalLUSDDeposits();\n    }\n    \n    // --- Pool interaction functions ---\n\n    // Add the received ETH to the total active collateral\n    function addColl() external payable onlyBorrowerOperations {\n        // Send ETH to Active Pool and increase its recorded ETH balance\n       (bool success, ) = activePoolAddress.call.value(msg.value)(\"\");\n       assert(success == true);\n    }\n    \n    // Transfer the specified amount of ETH to _account and updates the total active collateral\n    function withdrawColl(address _account, uint _ETH) external onlyBorrowerOperations {\n        activePool.sendETH(_account, _ETH);\n    }\n    \n    // Issue the specified amount of LUSD to _account and increases the total active debt\n    function withdrawLUSD(address _account, uint _LUSD) external onlyBorrowerOperations {\n        _withdrawLUSD(_account, _LUSD);\n    }\n\n    function _withdrawLUSD(address _account, uint _LUSD) internal {\n        activePool.increaseLUSDDebt(_LUSD);\n        LUSD.mint(_account, _LUSD);\n    }\n    \n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function repayLUSD(address _account, uint _LUSD) external onlyBorrowerOperations {\n        _repayLUSD(_account, _LUSD);\n    }\n\n    function _repayLUSD(address _account, uint _LUSD) internal {\n        activePool.decreaseLUSDDebt(_LUSD);\n        LUSD.burn(_account, _LUSD);\n    }\n\n    function lockLUSDGasCompensation(uint _LUSD) external onlyBorrowerOperations {\n        _withdrawLUSD(GAS_POOL_ADDRESS, _LUSD);\n    }\n\n    function refundLUSDGasCompensation(uint _LUSD) external onlyBorrowerOperations {\n        _repayLUSD(GAS_POOL_ADDRESS, _LUSD);\n    }\n\n    function sendLUSDGasCompensation(address _user, uint _LUSD) external onlyTroveManager {\n        LUSD.returnFromPool(GAS_POOL_ADDRESS, _user, _LUSD);\n    }\n\n    // Update the Active Pool and the Default Pool when a CDP gets liquidated\n    function liquidate(uint _LUSD, uint _ETH) external onlyTroveManager {\n        // Transfer the debt & coll from the Active Pool to the Default Pool\n        defaultPool.increaseLUSDDebt(_LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n        activePool.sendETH(defaultPoolAddress, _ETH);\n    }\n\n    // Move a CDP's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) external onlyTroveManager {\n        // Transfer the debt & coll from the Default Pool to the Active Pool\n        defaultPool.decreaseLUSDDebt(_LUSD);  \n        activePool.increaseLUSDDebt(_LUSD); \n        defaultPool.sendETH(activePoolAddress, _ETH); \n    }\n\n    // Burn the received LUSD, transfers the redeemed ETH to _account and updates the Active Pool\n    function redeemCollateral(address _account, uint _LUSD, uint _ETH) external onlyTroveManager {\n        // Update Active Pool LUSD, and send ETH to account\n        LUSD.burn(_account, _LUSD); \n        activePool.decreaseLUSDDebt(_LUSD);  \n\n        activePool.sendETH(_account, _ETH); \n    }\n\n    /*\n      Burn the remaining gas compensation LUSD, transfers the remaining ETH to _account and updates the Active Pool\n     * It’s called by TroveManager when after redemption there’s only gas compensation left as debt\n     */\n    function redeemCloseTrove(address _account, uint _LUSD, uint _ETH) external onlyTroveManager {\n        /*\n         * This is called by TroveManager when the redemption drains all the trove and there’s only the gas compensation left.\n         * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left correspond to the remaining collateral.\n         * In order to close the trove, the user should get the LUSD refunded and use them to repay and close it,\n         * but instead we do that all in one step.\n         */\n        LUSD.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_account, _ETH);\n    }\n\n    // Transfer the LUSD tokens from the user to the Stability Pool's address, and update its recorded LUSD\n    function _sendLUSDtoStabilityPool(address _address, uint _amount) internal {\n        LUSD.sendToPool(_address, stabilityPoolAddress, _amount);\n        stabilityPool.increaseLUSD(_amount);\n    }\n\n    // --- Reward calculator functions ---\n\n    function getCurrentETHGain(address _user) external view returns (uint) {\n        return _getCurrentETHGain(_user);\n    }\n\n    /* Return the ETH gain earned by the deposit. Given by the formula:  E = d0 * (S - S(0))/P(0)\n    where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively. */\n    function _getCurrentETHGain(address _user) internal view returns (uint) {\n        uint initialDeposit = initialDeposits[_user];\n\n        if (initialDeposit == 0) { return 0; }\n\n        uint snapshot_S = snapshot[_user].S;  \n        uint snapshot_P = snapshot[_user].P;\n        uint scaleSnapshot = snapshot[_user].scale;\n        uint epochSnapshot = snapshot[_user].epoch;\n\n        uint ETHGain;\n\n        /* Grab the reward sum from the epoch at which the deposit was made. The reward may span up to \n        one scale change.  \n        If it does, the second portion of the reward is scaled by 1e18. \n        If the reward spans no scale change, the second portion will be 0. */\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(snapshot_S);\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(1e18);\n\n        ETHGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(snapshot_P).div(1e18);\n        \n        return ETHGain;\n    }\n\n    function getCompoundedLUSDDeposit(address _user) external view returns (uint) {\n        return _getCompoundedLUSDDeposit(_user);\n    }\n\n    /* Return the user's compounded deposit.  Given by the formula:  d = d0 * P/P(0)\n    where P(0) is the depositor's snapshot of the product P. */\n    function _getCompoundedLUSDDeposit(address _user) internal view returns (uint) {\n        uint initialDeposit = initialDeposits[_user];\n\n        if (initialDeposit == 0) { return 0; }\n\n        uint snapshot_P = snapshot[_user].P; \n        uint128 scaleSnapshot = snapshot[_user].scale;\n        uint128 epochSnapshot = snapshot[_user].epoch;\n        \n        // If deposit was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedDeposit;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n    \n        /* Compute the compounded deposit. If a scale change in P was made during the deposit's lifetime, \n        account for it. If more than one scale change was made, then the deposit has decreased by a factor of \n        at least 1e-18 -- so return 0.*/\n        if (scaleDiff == 0) { \n            compoundedDeposit = initialDeposit.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedDeposit = initialDeposit.mul(P).div(snapshot_P).div(1e18);\n        } else {\n            compoundedDeposit = 0;\n        }\n\n        // If compounded deposit is less than a billionth of the initial deposit, return 0\n        if (compoundedDeposit < initialDeposit.div(1e9)) { return 0; }\n\n        return compoundedDeposit;\n    }\n\n    // --- Sender functions for LUSD deposits and ETH gains ---\n\n    function _sendETHGainToUser(address _address, uint ETHGain) internal {\n        stabilityPool.sendETH(_address, ETHGain);\n    }\n    \n    // Send ETHGain to CDP. Send in two steps: StabilityPool -> PoolManager -> user's CDP\n    function _sendETHGainToCDP(address _address, uint _ETHGain, address _hint) internal {\n        stabilityPool.sendETH(address(this), _ETHGain); \n        borrowerOperations.addColl.value(_ETHGain)(_address, _hint); \n    }\n\n    // Send LUSD to user and decrease LUSD in Pool\n    function _sendLUSDToUser(address _address, uint LUSDWithdrawal) internal {\n        uint LUSDinPool = stabilityPool.getTotalLUSDDeposits();\n        assert(LUSDWithdrawal <= LUSDinPool);\n\n        LUSD.returnFromPool(stabilityPoolAddress, _address, LUSDWithdrawal); \n        stabilityPool.decreaseLUSD(LUSDWithdrawal);\n    }\n\n    // --- Stability Pool Deposit Functionality --- \n\n    // Record a new deposit\n    function _updateDeposit(address _address, uint _amount) internal {\n        if (_amount == 0) {\n            initialDeposits[_address] = 0;\n            emit UserSnapshotUpdated(snapshot[_address].P, snapshot[_address].S);\n            return;\n        }\n\n        initialDeposits[_address] = _amount;\n    \n        // Record new individual snapshots of the running product P and sum S for the user\n        snapshot[_address].P = P;\n        snapshot[_address].S = epochToScaleToSum[currentEpoch][currentScale];\n        snapshot[_address].scale = currentScale;\n        snapshot[_address].epoch = currentEpoch;\n\n        emit UserSnapshotUpdated(snapshot[_address].P, snapshot[_address].S);\n    }\n \n    // --- External StabilityPool Functions ---\n\n    /* Send ETHGain to user's address, and updates their deposit, \n    setting newDeposit = compounded deposit + amount. */\n    function provideToSP(uint _amount) external {\n        address user = _msgSender();\n        uint initialDeposit = initialDeposits[user];\n\n        if (initialDeposit == 0) {\n            _sendLUSDtoStabilityPool(user, _amount);\n            _updateDeposit(user, _amount);\n        \n            emit UserDepositChanged(user, _amount);\n\n        } else { // If user already has a deposit, make a new composite deposit and retrieve their ETH gain\n            uint compoundedLUSDDeposit = _getCompoundedLUSDDeposit(user);\n            uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit);\n            uint ETHGain = _getCurrentETHGain(user);\n\n            uint newDeposit = compoundedLUSDDeposit.add(_amount);\n\n            _sendLUSDtoStabilityPool(user, _amount);\n            _updateDeposit(user, newDeposit);\n\n            _sendETHGainToUser(user, ETHGain);\n            \n            emit ETHGainWithdrawn(user, ETHGain, LUSDLoss);\n            emit UserDepositChanged(user, newDeposit); \n        }\n    }\n\n    /* Withdraw _amount of LUSD and the caller’s entire ETH gain from the \n    Stability Pool, and updates the caller’s reduced deposit. \n\n    If  _amount is 0, the user only withdraws their ETH gain, no LUSD.\n    If _amount > userDeposit, the user withdraws all their ETH gain, and all of their compounded deposit.\n\n    In all cases, the entire ETH gain is sent to user. */\n    function withdrawFromSP(uint _amount) external {\n        address user = _msgSender();\n        _requireUserHasDeposit(user); \n\n        uint initialDeposit = initialDeposits[user];\n        uint compoundedLUSDDeposit = _getCompoundedLUSDDeposit(user);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit);\n        uint ETHGain = _getCurrentETHGain(user);\n\n        uint LUSDtoWithdraw = Math._min(_amount, compoundedLUSDDeposit);\n        uint LUSDremainder = compoundedLUSDDeposit.sub(LUSDtoWithdraw);\n\n        _sendLUSDToUser(user, LUSDtoWithdraw);\n        _updateDeposit(user, LUSDremainder);\n      \n        _sendETHGainToUser(user, ETHGain);\n\n        emit ETHGainWithdrawn(user, ETHGain, LUSDLoss);\n        emit UserDepositChanged(user, LUSDremainder); \n    }\n\n    /* Transfer the caller's entire ETH gain from the Stability Pool to the caller's CDP, and leaves\n    their compounded deposit in the Stability Pool.\n    \n    TODO: Remove _user param and just use _msgSender(). */\n    function withdrawFromSPtoCDP(address _user, address _hint) external {\n        require(_user == _msgSender(), \"PoolManager: A user may only withdraw ETH gains to their own trove\" );\n        _requireUserHasDeposit(_user); \n        _requireUserHasTrove(_user);\n\n        uint initialDeposit = initialDeposits[_user];\n        uint compoundedLUSDDeposit = _getCompoundedLUSDDeposit(_user);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit);\n        uint ETHGain = _getCurrentETHGain(_user);\n       \n        // Update the recorded deposit value, and deposit snapshots\n        _updateDeposit(_user, compoundedLUSDDeposit);\n\n        /* Emit events before transferring ETH gain to CDP.\n         This lets the event log make more sense (i.e. so it appears that first the ETH gain is withdrawn \n        and then it is deposited into the CDP, not the other way around). */\n        emit ETHGainWithdrawn(_user, ETHGain, LUSDLoss);\n        emit UserDepositChanged(_user, compoundedLUSDDeposit); \n\n        _sendETHGainToCDP(_user, ETHGain, _hint);\n    }\n\n     /* Cancel out the specified _debt against the LUSD contained in the Stability Pool (as far as possible)  \n    and transfers the CDP's ETH collateral from ActivePool to StabilityPool. \n    Only called from liquidation functions in TroveManager. */\n    function offset(uint _debtToOffset, uint _collToAdd) \n    external \n    onlyTroveManager\n    {    \n        uint totalLUSDDeposits = stabilityPool.getTotalLUSDDeposits();\n        if (totalLUSDDeposits == 0 || _debtToOffset == 0) { return; }\n        \n        (uint ETHGainPerUnitStaked,\n         uint LUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalLUSDDeposits);\n\n        _updateRewardSumAndProduct(ETHGainPerUnitStaked, LUSDLossPerUnitStaked);\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(uint _collToAdd, uint _debtToOffset, uint _totalLUSDDeposits) \n    internal \n    returns (uint ETHGainPerUnitStaked, uint LUSDLossPerUnitStaked) \n    {\n        uint LUSDLossNumerator = _debtToOffset.mul(1e18).sub(lastLUSDLossError_Offset);\n        uint ETHNumerator = _collToAdd.mul(1e18).add(lastETHError_Offset);\n\n        // Compute the LUSD and ETH rewards, and error corrections\n        if (_debtToOffset >= _totalLUSDDeposits) {\n            LUSDLossPerUnitStaked = 1e18;\n            lastLUSDLossError_Offset = 0;\n        } else {\n            LUSDLossPerUnitStaked = (LUSDLossNumerator.div(_totalLUSDDeposits)).add(1); // add 1 to make error in quotient positive\n             lastLUSDLossError_Offset = (LUSDLossPerUnitStaked.mul(_totalLUSDDeposits)).sub(LUSDLossNumerator);\n        } \n\n        ETHGainPerUnitStaked = ETHNumerator.div(_totalLUSDDeposits); \n        lastETHError_Offset = ETHNumerator.sub(ETHGainPerUnitStaked.mul(_totalLUSDDeposits)); \n\n        return (ETHGainPerUnitStaked, LUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(uint _ETHGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {\n         // Make product factor 0 if there was a pool-emptying. Otherwise, it is (1 - LUSDLossPerUnitStaked)\n        uint newProductFactor = _LUSDLossPerUnitStaked >= 1e18 ? 0 : uint(1e18).sub(_LUSDLossPerUnitStaked);\n     \n        // Update the ETH reward sum at the current scale and current epoch\n        uint marginalETHGain = _ETHGainPerUnitStaked.mul(P);\n        epochToScaleToSum[currentEpoch][currentScale] = epochToScaleToSum[currentEpoch][currentScale].add(marginalETHGain);\n        emit S_Updated(epochToScaleToSum[currentEpoch][currentScale]); \n\n       // If the Pool was emptied, increment the epoch and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpoch.add(1);\n            currentScale = 0;\n            P = 1e18;\n    \n        // If multiplying P by a non-zero product factor would round P to zero, increment the scale \n        } else if (P.mul(newProductFactor) < 1e18) {\n            P = P.mul(newProductFactor);\n            currentScale = currentScale.add(1);\n         } else {\n            P = P.mul(newProductFactor).div(1e18); \n        }\n\n        emit P_Updated(P); \n    }\n\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\n        // Cancel the liquidated LUSD debt with the LUSD in the stability pool\n        activePool.decreaseLUSDDebt(_debtToOffset);  \n        stabilityPool.decreaseLUSD(_debtToOffset); \n       \n        // Send ETH from Active Pool to Stability Pool\n        activePool.sendETH(stabilityPoolAddress, _collToAdd);  \n\n        // Burn the debt that was successfully offset\n        LUSD.burn(stabilityPoolAddress, _debtToOffset); \n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireUserHasDeposit(address _address) internal view {\n        uint initialDeposit = initialDeposits[_address];  \n        require(initialDeposit > 0, 'PoolManager: User must have a non-zero deposit');  \n    }\n\n    function _requireUserHasTrove(address _user) internal view {\n        require(troveManager.getCDPStatus(_user) == 1, \"TroveManager: caller must have an active trove to withdraw ETHGain to\");\n    }\n\n    function () external payable onlyStabilityPool {}\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "pragma solidity 0.5.16;\n\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/IDeployedAggregator.sol\";\nimport \"./Interfaces/AggregatorInterface.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract PriceFeed is Ownable, IPriceFeed {\n    using SafeMath for uint256;\n\n    uint256 constant DIGITS = 1e18;\n    uint256 public price = 200 * DIGITS;\n\n    address public troveManagerAddress;\n    address public poolManagerAddress;\n    \n    // Mainnet Chainlink aggregator\n    address public priceAggregatorAddress;\n    IDeployedAggregator public priceAggregator;\n\n    // Testnet Chainlink aggregator\n    address public priceAggregatorAddress_Testnet;\n    AggregatorInterface public priceAggregator_Testnet;\n\n    event PriceUpdated(uint256 _newPrice);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event PoolManagerAddressChanged(address _poolManagerAddress);\n\n    // --- Modifiers ---\n\n    modifier onlyTroveManagerOrPoolManager {\n        require(_msgSender() == troveManagerAddress ||_msgSender() == poolManagerAddress,\n            \"PriceFeed: Caller is neither TroveManager nor PoolManager\"\n        );\n        _;\n    }\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _poolManagerAddress,\n        address _priceAggregatorAddress,\n        address _priceAggregatorAddressTestnet\n    )\n        external\n        onlyOwner\n    {\n        troveManagerAddress = _troveManagerAddress;\n        poolManagerAddress = _poolManagerAddress;\n        // Mainnet Chainlink address setter\n        priceAggregatorAddress = _priceAggregatorAddress;\n        priceAggregator = IDeployedAggregator(_priceAggregatorAddress);\n        // Testnet Chainlink address setter\n        priceAggregator_Testnet = AggregatorInterface(_priceAggregatorAddressTestnet);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    function getPrice() external view returns (uint256) {\n        return price;\n    }\n\n    // --- DEVELOPMENT FUNCTIONALITY - TODO: remove before mainnet deployment.  ---\n\n    // Manual external price setter. \n    function setPrice(uint256 _price) external returns (bool) {\n        price = _price;\n        emit PriceUpdated(price);\n        return true;\n    }\n\n    // --- MAINNET FUNCTIONALITY ---\n\n    // TODO: convert received Chainlink price to precision-18 before setting state variable\n    function updatePrice() external onlyTroveManagerOrPoolManager returns (uint256) {\n        price = getLatestPrice();\n        emit PriceUpdated(price);\n        return price;\n    }\n\n    function getLatestPrice() public view returns (uint256) {\n        int256 intPrice = priceAggregator.currentAnswer();\n        require(intPrice >= 0, \"Price response from aggregator is negative int\");\n\n        return uint256(intPrice);\n    }\n\n    function getLatestAnswerID() external view returns (uint256) {\n        return priceAggregator.latestCompletedAnswer();\n    }\n\n    // Get the block timestamp at which the reference price was last updated\n    function getLatestTimestamp() external view returns (uint256) {\n        return priceAggregator.updatedHeight();\n    }\n\n    // ---- ROPSTEN FUNCTIONALITY - TODO: Remove before Mainnet deployment ----\n\n    function updatePrice_Testnet() external returns (uint256) {\n        price = getLatestPrice_Testnet();\n        emit PriceUpdated(price);\n        return price;\n    }\n\n    function getLatestPrice_Testnet() public view returns (uint256) {\n        int256 intPrice = priceAggregator_Testnet.latestAnswer();\n        require( intPrice >= 0, \"Price response from aggregator is negative int\");\n\n        return uint256(intPrice).mul(10000000000);\n    }\n\n    // Get the block timestamp at which the reference data was last updated\n    function getLatestTimestamp_Testnet() external view returns (uint256) {\n        uint256 latestTimestamp = priceAggregator_Testnet.latestTimestamp();\n\n        return latestTimestamp;\n    }\n\n    // Get the past price from 'n' rounds ago\n    function getPreviousPrice_Testnet(uint256 _n) external view returns (uint256) {\n        uint256 latestAnswerID = priceAggregator_Testnet.latestRound();\n        require(_n <= latestAnswerID, \"Not enough history\");\n\n        int256 prevPrice = priceAggregator_Testnet.getAnswer(latestAnswerID - _n);\n        require(prevPrice >= 0, \"Price response from aggregator is negative int\");\n\n        return uint256(prevPrice).mul(10000000000);\n    }\n\n    // Get the block timestamp from the round that occurred 'n' rounds ago\n    function getPreviousTimestamp_Testnet(uint256 _n) external view returns (uint256) {\n        uint256 latestAnswerID = priceAggregator_Testnet.latestRound();\n        require(_n <= latestAnswerID, \"Not enough history\");\n\n        return priceAggregator_Testnet.getTimestamp(latestAnswerID - _n);\n    }\n}\n\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport './Interfaces/IStabilityPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract StabilityPool is Ownable, IStabilityPool {\n    using SafeMath for uint256;\n\n    address public poolManagerAddress;\n    address public activePoolAddress;\n    uint256 internal ETH;  // deposited ether tracker\n    \n    // Total LUSD held in the pool. Changes when users deposit/withdraw, and when CDP debt is offset.\n    uint256 internal totalLUSDDeposits;\n\n    // --- Modifiers ---\n\n    modifier onlyPoolManager {\n        require(_msgSender() == poolManagerAddress, \"StabilityPool:  Caller is not the PoolManager\");\n        _;\n    }\n\n    modifier onlyActivePool {\n        require(_msgSender() == activePoolAddress, \"StabilityPool: Caller is not ActivePool\");\n        _;\n    }\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _poolManagerAddress,\n        address _activePoolAddress\n    )\n        external\n        onlyOwner\n    {\n        poolManagerAddress = _poolManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit PoolManagerAddressChanged(_poolManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view returns (uint) {\n        return ETH;\n    }\n\n    function getTotalLUSDDeposits() external view returns (uint) {\n        return totalLUSDDeposits;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) external onlyPoolManager {\n        ETH = ETH.sub(_amount);\n        emit ETHBalanceUpdated(ETH);\n        emit EtherSent(_account, _amount);\n\n        (bool success, ) = _account.call.value(_amount)(\"\");  // use call.value()('') as per Consensys latest advice \n        require(success, \"StabilityPool: sending ETH failed\");\n    }\n\n    function increaseLUSD(uint _amount) external onlyPoolManager () {\n        totalLUSDDeposits  = totalLUSDDeposits.add(_amount);\n        emit LUSDBalanceUpdated(totalLUSDDeposits);\n    }\n\n    function decreaseLUSD(uint _amount) external onlyPoolManager () {\n        totalLUSDDeposits = totalLUSDDeposits.sub(_amount);\n        emit LUSDBalanceUpdated(totalLUSDDeposits);\n    }\n\n    /* Returns the raw ether balance at StabilityPool address.  \n    Not necessarily equal to the ETH state variable - ether can be forcibly sent to contracts. */\n    function getRawETHBalance() external view returns (uint) {\n        return address(this).balance;\n    }\n\n    function () external payable onlyActivePool {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/TestContracts/ActivePoolTester.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../ActivePool.sol\";\n\n\ncontract ActivePoolTester is ActivePool {\n    function unprotectedIncreaseLUSDDebt(uint _amount) external {\n        LUSDDebt  = LUSDDebt.add(_amount);\n    }\n\n    function unprotectedPayable() external payable {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/TestContracts/BorrowerOperationsTester.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../BorrowerOperations.sol\";\n\n/* Tester contract inherits from BorrowerOperations, and provides external functions \nfor testing the parent's internal functions. */\ncontract BorrowerOperationsTester is BorrowerOperations {\n\n    function getNewICRFromTroveChange(uint _coll, uint _debt, int _collChange, int _debtChange, uint _price) \n    external\n    pure\n    returns (uint)\n    {\n        return _getNewICRFromTroveChange(_coll, _debt, _collChange, _debtChange, _price);\n    }\n\n    function getNewTCRFromTroveChange(int _collChange, int _debtChange, uint _price) \n    external \n    view\n    returns (uint) \n    {\n        return _getNewTCRFromTroveChange(_collChange,  _debtChange, _price);\n    }\n\n    function getUSDValue(uint _coll, uint _price) external pure returns (uint) {\n        return _getUSDValue(_coll, _price);\n    }\n    \n}"
    },
    "contracts/TestContracts/TroveManagerTester.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../TroveManager.sol\";\nimport \"../Dependencies/Math.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n\n    function computeICR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return Math._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(uint _coll) external pure returns (uint) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getLUSDGasCompensation() external pure returns (uint) {\n        return LUSD_GAS_COMPENSATION;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function getActualDebtFromComposite(uint _debtVal) external pure returns (uint) {\n        return _getNetDebt(_debtVal);\n    }\n}\n"
    },
    "contracts/TestContracts/LUSDTokenTester.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../LUSDToken.sol\";\n\n\ncontract LUSDTokenTester is LUSDToken {\n    function unprotectedMint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/TestContracts/DefaultPoolTester.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../DefaultPool.sol\";\n\n\ncontract DefaultPoolTester is DefaultPool {\n    function unprotectedIncreaseLUSDDebt(uint _amount) external {\n        LUSDDebt  = LUSDDebt.add(_amount);\n    }\n\n    function unprotectedPayable() external payable {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/TestContracts/Destructible.sol": {
      "content": "pragma solidity 0.5.16;\n\n\ncontract Destructible {\n    function () external payable {}\n    function destruct(address payable _receiver) external {\n        selfdestruct(_receiver);\n    }\n}\n"
    },
    "contracts/TestContracts/FunctionCaller.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport '../Interfaces/ITroveManager.sol';\nimport '../Interfaces/ISortedCDPs.sol';\nimport '../Interfaces/IPriceFeed.sol';\nimport '../Dependencies/Math.sol';\n\n/* Wrapper contract - used for calculating gas of read-only and internal functions. \nNot part of the Liquity application. */\ncontract FunctionCaller {\n\n    ITroveManager troveManager;\n    address public troveManagerAddress;\n\n    ISortedCDPs sortedCDPs;\n    address public sortedCDPsAddress;\n\n    IPriceFeed priceFeed;\n    address public priceFeedAddress;\n\n    // --- Dependency setters ---\n\n    function setTroveManagerAddress(address _troveManagerAddress) external {\n        troveManagerAddress = _troveManagerAddress;\n        troveManager = ITroveManager(_troveManagerAddress);\n    }\n    \n    function setSortedCDPsAddress(address _sortedCDPsAddress) external {\n        troveManagerAddress = _sortedCDPsAddress;\n        sortedCDPs = ISortedCDPs(_sortedCDPsAddress);\n    }\n\n     function setPriceFeedAddress(address _priceFeedAddress) external {\n        priceFeedAddress = _priceFeedAddress;\n        priceFeed = IPriceFeed(_priceFeedAddress);\n    }\n\n    // --- PriceFeed functions -  non-view wrappers ---\n\n    // --- TroveManager functions - non-view wrappers ---\n    function troveManager_getCurrentICR (address _address, uint _price) external returns (uint) {\n        return troveManager.getCurrentICR(_address, _price);  \n    }\n\n    // --- SortedCDPs functions -  non-view wrappers ---\n\n    function sortedCDPs_findInsertPosition(uint _ICR, uint _price, address _prevId, address _nextId) external returns (address, address) {\n        return sortedCDPs.findInsertPosition(_ICR, _price, _prevId, _nextId);\n    }\n}\n"
    },
    "contracts/TestContracts/PoolManagerTester.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../PoolManager.sol\";\n\n\ncontract PoolManagerTester is PoolManager {\n    function lusdMint(address _account, uint _amount) external {\n        LUSD.mint(_account, _amount);\n    }\n\n    function lusdBurn(address _account, uint _amount) external {\n        LUSD.burn(_account, _amount);\n    }\n\n    function lusdSendToPool(address _sender,  address _poolAddress, uint256 _amount) external {\n        LUSD.sendToPool(_sender, _poolAddress, _amount);\n    }\n\n    function lusdReturnFromPool(address _poolAddress, address _receiver, uint256 _amount ) external {\n        LUSD.returnFromPool(_poolAddress, _receiver, _amount);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}