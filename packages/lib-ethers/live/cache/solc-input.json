{
  "language": "Solidity",
  "sources": {
    "contracts/ActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n\n/* \n * The Active Pool holds the ETH collateral and LUSD debt (but not LUSD tokens) for all active troves.\n * \n * When a trove is liquidated, it's ETH and LUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n * \n */\ncontract ActivePool is Ownable, IPool {\n    using SafeMath for uint256;\n\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    uint256 internal ETH;  // deposited ether tracker\n    uint256 internal LUSDDebt;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress\n    )\n        external\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /* \n    * Returns the ETH state variable.\n    *\n    *Not necessarily equal to the the contract's raw ETH balance - ether can be forcibly sent to contracts. \n    */\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getLUSDDebt() external view override returns (uint) {\n        return LUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        ETH = ETH.sub(_amount);\n        emit EtherSent(_account, _amount);\n\n        (bool success, ) = _account.call{ value: _amount }(\"\");\n        require(success, \"ActivePool: sending ETH failed\");\n    }\n\n    function increaseLUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveM();\n        LUSDDebt  = LUSDDebt.add(_amount);\n    }\n\n    function decreaseLUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        LUSDDebt = LUSDDebt.sub(_amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress ||\n            msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\");\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\");\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/Interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// Common interface for the Pools.\ninterface IPool {\n    \n    // --- Events ---\n    \n    event ETHBalanceUpdated(uint _newBalance);\n\n    event LUSDBalanceUpdated(uint _newBalance);\n\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    \n    function getETH() external view returns (uint);\n\n    function getLUSDDebt() external view returns (uint);\n\n    function sendETH(address _account, uint _amount) external;\n\n    function increaseLUSDDebt(uint _amount) external;\n\n    function decreaseLUSDDebt(uint _amount) external;\n}\n"
    },
    "contracts/Dependencies/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n/**\n * Based on OpenZeppelin's SafeMath:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n *\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Dependencies/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n/**\n * Based on OpenZeppelin's Ownable contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n *\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     *\n     * NOTE: This function is not safe, as it doesn’t check owner is calling it.\n     * Make sure you check it before calling it.\n     */\n    function _renounceOwnership() internal {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n}\n"
    },
    "contracts/Dependencies/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// Buidler's helper contract for console logging\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/IPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport './Interfaces/ILUSDToken.sol';\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, IBorrowerOperations {\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    address stabilityPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    ILUSDToken public lusdToken;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n     struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint rawDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint newICR;\n        uint LUSDFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        addColl,\n        withdrawColl,\n        withdrawLUSD,\n        repayLUSD,\n        adjustTrove\n    }\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, BorrowerOperation operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint _LUSDAmount, address _hint) external payable override {\n        uint price = priceFeed.getPrice();\n\n        _requireTroveisNotActive(msg.sender);\n\n        // Decay the base rate, and calculate the borrowing fee\n        troveManager.decayBaseRateFromBorrowing();\n        uint LUSDFee = troveManager.getBorrowingFee(_LUSDAmount);\n        uint rawDebt = _LUSDAmount.add(LUSDFee);\n\n        // ICR is based on the composite debt, i.e. the requested LUSD amount + LUSD borrowing fee + LUSD gas comp.\n        uint compositeDebt = _getCompositeDebt(rawDebt);\n        assert(compositeDebt > 0);\n        uint ICR = LiquityMath._computeCR(msg.value, compositeDebt, price);\n\n        if (_checkRecoveryMode()) {\n            _requireICRisAboveR_MCR(ICR);\n        } else {\n            _requireICRisAboveMCR(ICR);\n            _requireNewTCRisAboveCCR(msg.value, true, compositeDebt, true, price);  // bools: coll increase, debt increase\n        }\n\n        // Set the trove struct's properties\n        troveManager.setTroveStatus(msg.sender, 1);\n        troveManager.increaseTroveColl(msg.sender, msg.value);\n        troveManager.increaseTroveDebt(msg.sender, compositeDebt);\n\n        troveManager.updateTroveRewardSnapshots(msg.sender);\n        uint stake = troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, ICR, price, _hint, _hint);\n        uint arrayIndex = troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, arrayIndex);\n\n        // Send the LUSD borrowing fee to the staking contract\n        lusdToken.mint(lqtyStakingAddress, LUSDFee);\n        lqtyStaking.increaseF_LUSD(LUSDFee);\n\n        // Move the ether to the Active Pool, and mint the LUSDAmount to the borrower\n        _activePoolAddColl(msg.value);\n        _withdrawLUSD(msg.sender, _LUSDAmount, rawDebt);\n        // Move the LUSD gas compensation to the Gas Pool\n        _withdrawLUSD(GAS_POOL_ADDRESS, LUSD_GAS_COMPENSATION, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, rawDebt, msg.value, stake, BorrowerOperation.openTrove);\n        emit LUSDBorrowingFeePaid(msg.sender, LUSDFee);\n    }\n\n    // Send ETH as collateral to a trove\n    function addColl(address _hint) external payable override {\n        _adjustTrove(msg.sender, 0, 0, false, _hint);\n    }\n\n    // Send ETH as collateral to a trove. Called by only the Stability Pool.\n    function moveETHGainToTrove(address _borrower, address _hint) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _hint);\n    }\n\n    // Withdraw ETH collateral from a trove\n    function withdrawColl(uint _collWithdrawal, address _hint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, _hint);\n    }\n\n    // Withdraw LUSD tokens from a trove: mint new LUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawLUSD(uint _LUSDAmount, address _hint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, true, _hint);\n    }\n\n    // Repay LUSD tokens to a Trove: Burn the repaid LUSD tokens, and reduce the trove's debt accordingly\n    function repayLUSD(uint _LUSDAmount, address _hint) external override {\n        _adjustTrove(msg.sender, 0, _LUSDAmount, false, _hint);\n    }\n\n    /*\n    * If ETH is sent, the operation is considered as a collateral increase, and the first parameter\n    * _collWithdrawal must be zero\n    */\n    function adjustTrove(uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _hint) external payable override {\n        _adjustTrove(msg.sender, _collWithdrawal, _debtChange, _isDebtIncrease, _hint);\n    }\n\n    function _adjustTrove(address _borrower, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _hint) internal {\n        require(msg.value == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n        // The operation \"isWithdrawal\" if it removes collateral or LUSD, i.e. it removes funds and lowers the ICR\n        bool isWithdrawal = _collWithdrawal != 0 || _isDebtIncrease;\n        require(msg.sender == _borrower || !isWithdrawal, \"BorrowerOps: User must be sender for withdrawals\");\n        require(msg.value != 0 || _collWithdrawal != 0 || _debtChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n\n        LocalVariables_adjustTrove memory L;\n\n        _requireTroveisActive(_borrower);\n        if (isWithdrawal) {_requireNotInRecoveryMode();}\n\n        L.price = priceFeed.getPrice();\n\n        troveManager.applyPendingRewards(_borrower);\n\n        (L.collChange, L.isCollIncrease) = _getCollChange(msg.value, _collWithdrawal);\n\n        L.rawDebtChange = _debtChange;\n        if (_isDebtIncrease && _debtChange > 0) {\n            // Decay the baseRate and get the fee\n            troveManager.decayBaseRateFromBorrowing();\n            L.LUSDFee = troveManager.getBorrowingFee(_debtChange);\n\n            // The raw debt change includes the fee, if there was one\n            L.rawDebtChange = L.rawDebtChange.add(L.LUSDFee);\n\n            // Send fee to LQTY staking contract\n            lqtyStaking.increaseF_LUSD(L.LUSDFee);\n            lusdToken.mint(lqtyStakingAddress, L.LUSDFee);\n        }\n\n        L.debt = troveManager.getTroveDebt(_borrower);\n        L.coll = troveManager.getTroveColl(_borrower);\n\n        L.newICR = _getNewICRFromTroveChange(L.coll, L.debt, L.collChange, L.isCollIncrease, L.rawDebtChange, _isDebtIncrease, L.price);\n\n        if (isWithdrawal) {_requireICRisAboveMCR(L.newICR);}\n        if (_isDebtIncrease && _debtChange > 0) {\n            _requireNewTCRisAboveCCR(L.collChange, L.isCollIncrease, L.rawDebtChange, _isDebtIncrease, L.price);\n        }\n        if (!L.isCollIncrease) {_requireCollAmountIsWithdrawable(L.coll, L.collChange);}\n        if (!_isDebtIncrease && _debtChange > 0) {_requireLUSDRepaymentAllowed(L.debt, L.rawDebtChange);}\n\n        (L.newColl, L.newDebt) = _updateTroveFromAdjustment(_borrower, L.collChange, L.isCollIncrease, L.rawDebtChange, _isDebtIncrease);\n        L.stake = troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove it in the sorted list\n        sortedTroves.reInsert(_borrower, L.newICR, L.price, _hint, _hint);\n\n        // Pass unmodified _debtChange here, as we don't send the fee to the user\n        _moveTokensAndETHfromAdjustment(msg.sender, L.collChange, L.isCollIncrease, _debtChange, _isDebtIncrease, L.rawDebtChange);\n\n        emit TroveUpdated(_borrower, L.newDebt, L.newColl, L.stake, BorrowerOperation.adjustTrove);\n        emit LUSDBorrowingFeePaid(msg.sender,  L.LUSDFee);\n    }\n\n    function closeTrove() external override {\n        _requireTroveisActive(msg.sender);\n        _requireNotInRecoveryMode();\n\n        troveManager.applyPendingRewards(msg.sender);\n\n        uint coll = troveManager.getTroveColl(msg.sender);\n        uint debt = troveManager.getTroveDebt(msg.sender);\n\n        troveManager.removeStake(msg.sender);\n        troveManager.closeTrove(msg.sender);\n\n        // Burn the debt from the user's balance, and send the collateral back to the user\n        _repayLUSD(msg.sender, debt.sub(LUSD_GAS_COMPENSATION));\n        activePool.sendETH(msg.sender, coll);\n        // Refund gas compensation\n        _repayLUSD(GAS_POOL_ADDRESS, LUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n    }\n\n    function claimRedeemedCollateral(address _user) external override {\n        // send ETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(_user);\n\n        emit RedeemedCollateralClaimed(_user);\n    }\n\n    // --- Helper functions ---\n\n    function _getUSDValue(uint _coll, uint _price) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(1e18);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint newColl = (_isCollIncrease) ? troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease) ? troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndETHfromAdjustment\n    (\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _rawDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawLUSD(_borrower, _debtChange, _rawDebtChange);\n        } else {\n            _repayLUSD(_borrower, _debtChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_collChange);\n        } else {\n            activePool.sendETH(_borrower, _collChange);\n        }\n    }\n\n    // Send ETH to Active Pool and increase its recorded ETH balance\n    function _activePoolAddColl(uint _amount) internal {\n        (bool success, ) = address(activePool).call{value: _amount}(\"\");\n        assert(success == true);\n    }\n\n    // Issue the specified amount of LUSD to _account and increases the total active debt (_rawDebtIncrease potentially includes a LUSDFee)\n    function _withdrawLUSD(address _account, uint _LUSDAmount, uint _rawDebtIncrease) internal {\n        activePool.increaseLUSDDebt(_rawDebtIncrease);\n        lusdToken.mint(_account, _LUSDAmount);\n    }\n\n    // Burn the specified amount of LUSD from _account and decreases the total active debt\n    function _repayLUSD(address _account, uint _LUSD) internal {\n        activePool.decreaseLUSDDebt(_LUSD);\n        lusdToken.burn(_account, _LUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireTroveisActive(address _borrower) internal view {\n        uint status = troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(address _borrower) internal view {\n        uint status = troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(_checkRecoveryMode() == false, \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireICRisAboveMCR(uint _newICR)  internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveR_MCR(uint _newICR) internal pure {\n        require(_newICR >= R_MCR, \"BorrowerOps: In Recovery Mode new troves must have ICR >= R_MCR\");\n    }\n\n    function _requireNewTCRisAboveCCR\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n    {\n        uint newTCR = _getNewTCRFromTroveChange(_collChange, _isCollIncrease, _debtChange, _isDebtIncrease, _price);\n        require(newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireLUSDRepaymentAllowed(uint _currentDebt, uint _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt.sub(LUSD_GAS_COMPENSATION), \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCollAmountIsWithdrawable(uint _currentColl, uint _collWithdrawal)\n        internal\n        pure\n    {\n        require(_collWithdrawal <= _currentColl, \"BorrowerOps: Insufficient balance for ETH withdrawal\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n    // --- ICR and TCR checks ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll.add(_collChange) :  _coll.sub(_collChange);\n        newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint totalColl = activePool.getETH().add(defaultPool.getETH());\n        uint totalDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt = totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function _checkRecoveryMode() internal view returns (bool) {\n        uint TCR = _getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _getTCR() internal view returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint activeColl = activePool.getETH();\n        uint activeDebt = activePool.getLUSDDebt();\n        uint liquidatedColl = defaultPool.getETH();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        uint totalCollateral = activeColl.add(liquidatedColl);\n        uint totalDebt = activeDebt.add(closedDebt);\n\n        TCR = LiquityMath._computeCR(totalCollateral, totalDebt, price);\n\n        return TCR;\n    }\n}\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event RedeemedCollateralClaimed(address indexed _user);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _lusdTokenAddress,\n        address _lqtyStakingAddress\n    ) external;\n\n    function openTrove(uint _LUSDAmount, address _hint) external payable;\n\n    function addColl(address _hint) external payable;\n\n    function moveETHGainToTrove(address _user, address _hint) external payable;\n\n    function withdrawColl(uint _amount, address _hint) external;\n\n    function withdrawLUSD(uint _amount, address _hint) external;\n\n    function repayLUSD(uint _amount, address _hint) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _hint) external payable;\n\n    function claimRedeemedCollateral(address _user) external;\n\n    function getCompositeDebt(uint _debt) external pure returns (uint);\n}\n"
    },
    "contracts/Interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// Common interface for the Trove Manager.\ninterface ITroveManager {\n    \n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    \n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    ) external;\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\n\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function checkRecoveryMode() external view returns (bool);\n\n    function redeemCollateral(\n        uint _LUSDAmount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    ) external; \n\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingETHReward(address _borrower) external view returns (uint);\n\n    function getPendingLUSDDebtReward(address _borrower) external view returns (uint);\n\n     function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(address _borrower) external view returns (\n        uint debt, \n        uint coll, \n        uint pendingLUSDDebtReward, \n        uint pendingETHReward\n    );\n\n    function getEntireSystemColl() external view returns (uint);\n\n    function getEntireSystemDebt() external view returns (uint);\n\n    function getTCR() external view returns (uint TCR);\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint);\n    \n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function setTroveStatus(address _borrower, uint num) external;\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \n\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \n}\n"
    },
    "contracts/Interfaces/ILUSDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/IERC20.sol\";\nimport \"../Dependencies/IERC2612.sol\";\n\ninterface ILUSDToken is IERC20, IERC2612 { \n    \n    // --- Events ---\n    event LUSDTokenBalanceUpdated(address _user, uint _amount);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    // --- Functions ---\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\n}\n"
    },
    "contracts/Dependencies/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n/**\n * Based on the OpenZeppelin IER20 interface:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n *\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    \n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/Dependencies/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n * \n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, \n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    \n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \n     * a value in the near future. The deadline argument can be set to uint(-1) to \n     * create Permits that effectively never expire.\n     */\n    function nonces(address owner) external view returns (uint256);\n    \n    function version() external view returns (string memory);\n    function permitTypeHash() external view returns (bytes32);\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/Interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n\ninterface ICollSurplusPool {\n    event CollBalanceUpdated(address _account, uint _newBalance);\n    event EtherSent(address _to, uint _amount);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getETH() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n\n    function accountSurplus(address _account, uint _amount) external;\n\n    function claimColl(address _account) external;\n}\n"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ninterface IPriceFeed {\n\n    function getPrice() external view returns (uint);\n}\n"
    },
    "contracts/Interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n\n    // --- Events ---\n    \n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n    // --- Functions ---\n    \n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\n\n    function insert(address _id, uint256 _ICR, uint price, address _prevId, address _nextId) external;\n\n    function remove(address _id) external;\n\n    function reInsert(address _id, uint256 _newICR, uint price, address _prevId, address _nextId) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) external view returns (bool);\n\n    function findInsertPosition(uint256 _ICR, uint _price,  address _prevId, address _nextId) external view returns (address, address);\n}\n"
    },
    "contracts/Interfaces/ILQTYStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ninterface ILQTYStaking {\n\n    function setAddresses\n    (\n        address _lqtyTokenAddress,\n        address _lusdTokenAddress,\n        address _troveManagerAddress, \n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    )  external;\n\n    function stake(uint _LQTYamount) external;\n\n    function unstake(uint _LQTYamount) external;\n\n    function increaseF_ETH(uint _ETHFee) external; \n\n    function increaseF_LUSD(uint _LQTYFee) external;  \n\n    function getPendingETHGain(address _user) external view returns (uint);\n\n    function getPendingLUSDGain(address _user) external view returns (uint);\n}\n"
    },
    "contracts/Dependencies/LiquityBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./LiquityMath.sol\";\n\n/* \n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n* common functions. \n*/\ncontract LiquityBase {\n    using SafeMath for uint;\n\n    address constant public GAS_POOL_ADDRESS = 0x00000000000000000000000000000000000009A5;\n\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint constant public MCR = 1100000000000000000; // 110%\n\n    // Minimum collateral ratio for individual troves newly opened in Recovery Mode\n    uint constant public R_MCR = 3000000000000000000; // 300%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint constant public  CCR = 1500000000000000000; // 150%\n\n    // Amount of LUSD to be locked in gas pool on opening troves\n    uint constant public LUSD_GAS_COMPENSATION = 10e18;\n\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\n        return _debt.add(LUSD_GAS_COMPENSATION);\n    }\n\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\n        return _debt.sub(LUSD_GAS_COMPENSATION);\n    }\n\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n}\n"
    },
    "contracts/Dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./SafeMath.sol\";\nimport \"./console.sol\";\n\nlibrary LiquityMath {\n    using SafeMath for uint;\n\n    function _min(uint _a, uint _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /* multiply two decimal numbers and use normal rounding rules:\n    * -round product up if 19th mantissa digit >= 5\n    * -round product down if 19th mantissa digit < 5\n    *\n    * Used only inside the exponentiation, _decPow().\n    */\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\n        uint prod_xy = x.mul(y);\n\n        decProd = prod_xy.add(1e18 / 2).div(1e18);\n    }\n\n    /* _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n. \n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \n    * \n    * Called by two functions that represent time in units of minutes:\n    * 1) TroveManager._calcDecayedBaseRate\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \n    * \n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n    * \n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n    * negligibly different from just passing the cap, since: \n    *\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n    */\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n       \n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\n    \n        if (_minutes == 0) {return 1e18;}\n\n        uint y = 1e18;\n        uint x = _base;\n        uint n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n.div(2);\n            } else { // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n.sub(1)).div(2);\n            }\n        }\n\n        return decMul(x, y);\n  }\n\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n    }\n\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else { // if (_debt == 0)\n            return 2**256 - 1; \n        }\n    }\n}\n"
    },
    "contracts/CollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n\ncontract CollSurplusPool is Ownable, ICollSurplusPool {\n    using SafeMath for uint256;\n\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public activePoolAddress;\n\n    // deposited ether tracker\n    uint256 internal ETH;\n    // Collateral surplus claimable by trove owners\n    mapping (address => uint) internal balances;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        _renounceOwnership();\n    }\n\n    /* Returns the ETH state variable at ActivePool address.\n       Not necessarily equal to the raw ether balance - ether can be forcibly sent to contracts. */\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getCollateral(address _account) external view override returns (uint) {\n        return balances[_account];\n    }\n\n    // --- Pool functionality ---\n\n    function accountSurplus(address _account, uint _amount) external override {\n        _requireCallerIsTroveManager();\n\n        uint newAmount = balances[_account].add(_amount);\n        balances[_account] = newAmount;\n\n        emit CollBalanceUpdated(_account, newAmount);\n    }\n\n    function claimColl(address _account) external override {\n        _requireCallerIsBorrowerOperations();\n        uint claimableColl = balances[_account];\n        require(claimableColl > 0, \"CollSurplusPool: No collateral available to claim\");\n\n        balances[_account] = 0;\n        emit CollBalanceUpdated(_account, 0);\n\n        ETH = ETH.sub(claimableColl);\n        emit EtherSent(_account, claimableColl);\n\n        (bool success, ) = _account.call{ value: claimableColl }(\"\");\n        require(success, \"CollSurplusPool: sending ETH failed\");\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"CollSurplusPool: Caller is not Borrower Operations\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == troveManagerAddress,\n            \"CollSurplusPool: Caller is not TroveManager\");\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == activePoolAddress,\n            \"CollSurplusPool: Caller is not Active Pool\");\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/DefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IPool.sol';\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/* \n * The Default Pool holds the ETH and LUSD debt (but not LUSD tokens) from liquidations that have been redistributed\n * to active troves but not yet \"applied\", i.e. not yet recorded on a recipient active trove's struct.\n * \n * When a trove makes an operation that applies its pending ETH and LUSD debt, its pending ETH and LUSD debt is moved\n * from the Default Pool to the Active Pool.\n */\ncontract DefaultPool is Ownable, IPool {\n    using SafeMath for uint256;\n\n    address public troveManagerAddress;\n    address public activePoolAddress;\n    uint256 internal ETH;  // deposited ETH tracker\n    uint256 internal LUSDDebt;  // debt \n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress\n    )\n        external\n        onlyOwner\n    {\n        troveManagerAddress = _troveManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /* \n    * Returns the ETH state variable.\n    *\n    * Not necessarily equal to the the contract's raw ETH balance - ether can be forcibly sent to contracts. \n    */\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getLUSDDebt() external view override returns (uint) {\n        return LUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendETH(address _account, uint _amount) external override {\n        _requireCallerIsTroveManager();\n        ETH = ETH.sub(_amount);\n        emit EtherSent(_account, _amount);\n\n        (bool success, ) = _account.call{ value: _amount }(\"\"); \n        require(success, \"DefaultPool: sending ETH failed\");\n    }\n\n    function increaseLUSDDebt(uint _amount) external override {\n        _requireCallerIsTroveManager();\n        LUSDDebt = LUSDDebt.add(_amount);\n    }\n\n    function decreaseLUSDDebt(uint _amount) external override {\n        _requireCallerIsTroveManager();\n        LUSDDebt = LUSDDebt.sub(_amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(msg.sender == activePoolAddress, \"DefaultPool: Caller is not the ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"DefaultPool: Caller is not the TroveManager\");\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/Dependencies/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\npragma solidity 0.6.11;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/Dependencies/LiquitySafeMath128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n// uint128 addition and subtraction, with overflow protection.\n\nlibrary LiquitySafeMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c = a + b;\n        require(c >= a, \"LiquitySafeMath128: addition overflow\");\n\n        return c;\n    }\n   \n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b <= a, \"LiquitySafeMath128: subtraction overflow\");\n        uint128 c = a - b;\n\n        return c;\n    }\n}"
    },
    "contracts/HintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\n\ncontract HintHelpers is LiquityBase, Ownable {\n\n    ISortedTroves public sortedTroves;\n    ITroveManager public troveManager;\n\n    // --- Events ---\n\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _sortedTrovesAddress,\n        address _troveManagerAddress\n    )\n        external\n        onlyOwner\n    {\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /* getRedemptionHints() - Helper function for redeemCollateral().\n     *\n     * Find the first and last Troves that will modified by calling redeemCollateral() with the same _LUSDamount and _price,\n     * and return the address of the first one and the final ICR of the last one.\n     */\n\n    function getRedemptionHints(\n        uint _LUSDamount, \n        uint _price\n    )\n        external\n        view\n        returns (address firstRedemptionHint, uint partialRedemptionHintICR)\n    {\n        uint remainingLUSD = _LUSDamount;\n        address currentTroveuser = sortedTroves.getLast();\n\n        while (currentTroveuser != address(0) && troveManager.getCurrentICR(currentTroveuser, _price) < MCR) {\n            currentTroveuser = sortedTroves.getPrev(currentTroveuser);\n        }\n\n        firstRedemptionHint = currentTroveuser;\n\n        while (currentTroveuser != address(0) && remainingLUSD > 0) {\n            uint LUSDDebt = _getNetDebt(troveManager.getTroveDebt(currentTroveuser))\n                                     .add(troveManager.getPendingLUSDDebtReward(currentTroveuser));\n\n            if (LUSDDebt > remainingLUSD) {\n                uint ETH = troveManager.getTroveColl(currentTroveuser)\n                                     .add(troveManager.getPendingETHReward(currentTroveuser));\n                \n                uint newColl = ETH.sub(remainingLUSD.mul(1e18).div(_price));\n                uint newDebt = LUSDDebt.sub(remainingLUSD);\n                \n                uint compositeDebt = _getCompositeDebt(newDebt);\n                partialRedemptionHintICR = LiquityMath._computeCR(newColl, compositeDebt, _price);\n\n                break;\n            } else {\n                remainingLUSD = remainingLUSD.sub(LUSDDebt);\n            }\n            currentTroveuser = sortedTroves.getPrev(currentTroveuser);\n        }\n    }\n\n    /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the \n    sortedTroves list from the correct insert position of the Trove to be inserted. \n    \n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \n    be <= sqrt(length) positions away from the correct insert position.\n    */\n    function getApproxHint(uint _CR, uint _numTrials, uint _price, uint _inputRandomSeed)\n        external\n        view\n        returns (address hintAddress, uint diff, uint latestRandomSeed)\n    {\n        uint arrayLength = troveManager.getTroveOwnersCount();\n\n        if (arrayLength == 0) {\n            return (address(0), 0, _inputRandomSeed);\n        }\n\n        hintAddress = sortedTroves.getLast();\n        diff = LiquityMath._getAbsoluteDifference(_CR, troveManager.getCurrentICR(hintAddress, _price));\n        latestRandomSeed = _inputRandomSeed;\n\n        uint i = 1;\n\n        while (i < _numTrials) {\n            latestRandomSeed = uint(keccak256(abi.encodePacked(latestRandomSeed)));\n\n            uint arrayIndex = latestRandomSeed % arrayLength;\n            address currentAddress = troveManager.getTroveFromTroveOwnersArray(arrayIndex);\n            uint currentICR = troveManager.getCurrentICR(currentAddress, _price);\n\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n            uint currentDiff = LiquityMath._getAbsoluteDifference(currentICR, _CR);\n\n            if (currentDiff < diff) {\n                diff = currentDiff;\n                hintAddress = currentAddress;\n            }\n            i++;\n        }\n    }\n\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return LiquityMath._computeCR(_coll, _debt, _price);\n    }\n}\n"
    },
    "contracts/Interfaces/ICommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ninterface ICommunityIssuance { \n    \n    // --- Events ---\n    \n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n    \n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\n\n    // --- Functions ---\n\n    function setAddresses(address _lqtyTokenAddress, address _stabilityPoolAddress) external;\n\n    function issueLQTY() external returns (uint);\n\n    function sendLQTY(address _account, uint _LQTYamount) external;\n}\n"
    },
    "contracts/Interfaces/ILockupContractFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n    \ninterface ILockupContractFactory {\n    \n    // --- Events ---\n\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n\n    // --- Functions ---\n\n    function setLQTYTokenAddress(address _lqtyTokenAddress) external;\n\n    function deployOneYearLockupContract(address beneficiary, uint initialEntitlement) external;\n\n    function deployCustomDurationLockupContract(address beneficiary, uint entitlement, uint lockupDuration) external;\n\n    function lockOneYearContracts(address[] calldata addresses) external;\n\n    function lockCustomDurationContracts(address[] calldata addresses) external;\n\n    function isRegisteredOneYearLockup(address _addr) external view returns (bool);\n\n    function isRegisteredCustomDurationLockup(address _contractAddress) external view returns (bool);\n}\n"
    },
    "contracts/Interfaces/ILQTYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/IERC20.sol\";\nimport \"../Dependencies/IERC2612.sol\";\n\ninterface ILQTYToken is IERC20, IERC2612 { \n   \n    // --- Events ---\n    \n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\n\n    event LQTYStakingAddressSet(address _lqtyStakingAddress);\n    \n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\n\n    // --- Functions ---\n    \n    function sendToLQTYStaking(address _sender, uint256 _amount) external;\n}\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ninterface IStabilityPool {\n    \n    // --- Events ---\n    \n    event ETHBalanceUpdated(uint _newBalance);\n    event LUSDBalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S);\n    event G_Updated(uint _G);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\n\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\n\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n    \n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    ) external;\n\n    function provideToSP(uint _amount, address _frontEndTag) external;\n    function withdrawFromSP(uint _amount) external;\n    function withdrawETHGainToTrove(address _hint) external;\n\n    function registerFrontEnd(uint _kickbackRate) external;\n\n    function offset(uint _debt, uint _coll) external;\n\n    function getETH() external view returns (uint);\n    function getTotalLUSDDeposits() external view returns (uint);\n\n    function getDepositorETHGain(address _depositor) external view returns (uint);\n    function getDepositorLQTYGain(address _depositor) external view returns (uint);\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint);\n\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint);\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\n}\n"
    },
    "contracts/LQTY/CommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/ILQTYToken.sol\";\nimport \"../Interfaces/ICommunityIssuance.sol\";\nimport \"../Dependencies/LiquityMath.sol\";\nimport \"../Dependencies/Ownable.sol\";\nimport \"../Dependencies/SafeMath.sol\";\n\n//TODO: Decide upon and implement LQTY community issuance schedule.\ncontract CommunityIssuance is ICommunityIssuance, Ownable {\n    using SafeMath for uint;\n\n    // --- Data ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n\n   /* The issuance factor F determines the curvature of the issuance curve.\n    *\n    * Minutes in one year: 60*24*365 = 525600\n    *\n    * For 50% of remaining tokens issued each year, with minutes as time units, we have:\n    * \n    * F ** 525600 = 0.5\n    * \n    * Re-arranging:\n    * \n    * 525600 * ln(F) = ln(0.5)\n    * F = 0.5 ** (1/525600)\n    * F = 0.999998681227695000 \n    */\n    uint constant public ISSUANCE_FACTOR = 999998681227695000;\n\n    /* The community LQTY supply cap is the starting balance of the Community Issuance contract.\n    Liquity admin should transfer LQTY to this CommunityIssuance contract before activating it.\n\n    Set to 1/3 of total LQTY supply.*/\n    uint constant public LQTYSupplyCap = 33333333333333333333333333; // (1/3) * 100 million\n\n    ILQTYToken public lqtyToken;\n\n    address public stabilityPoolAddress;\n\n    uint public totalLQTYIssued;\n    uint public deploymentTime;\n\n    // --- Events ---\n\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\n\n    // --- Functions ---\n\n    constructor() public {\n        deploymentTime = block.timestamp;\n    }\n\n    function setAddresses\n    (\n        address _lqtyTokenAddress, \n        address _stabilityPoolAddress\n    ) \n        external \n        onlyOwner \n        override \n    {\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n\n        // When LQTYToken deployed, it should have transferred CommunityIssuance's LQTY entitlement\n        uint LQTYBalance = lqtyToken.balanceOf(address(this));\n        assert(LQTYBalance >= LQTYSupplyCap);\n\n        emit LQTYTokenAddressSet(_lqtyTokenAddress);\n        emit StabilityPoolAddressSet(_stabilityPoolAddress);\n\n        _renounceOwnership();\n    }\n\n    function issueLQTY() external override returns (uint) {\n        _requireCallerIsStabilityPool();\n\n        uint latestTotalLQTYIssued = LQTYSupplyCap.mul(_getCumulativeIssuanceFraction()).div(1e18);\n        uint issuance = latestTotalLQTYIssued.sub(totalLQTYIssued);\n\n        totalLQTYIssued = latestTotalLQTYIssued;\n        return issuance;\n    }\n\n    /* Gets 1-f^t    where: f < 1\n\n    f: issuance factor that determines the shape of the curve\n    t:  time passed since last LQTY issuance event  */\n    function _getCumulativeIssuanceFraction() internal view returns (uint) {\n        // Get the time passed since deployment\n        uint timePassedInMinutes = block.timestamp.sub(deploymentTime).div(SECONDS_IN_ONE_MINUTE);\n\n        // f^t\n        uint power = LiquityMath._decPow(ISSUANCE_FACTOR, timePassedInMinutes);\n\n        //  (1 - f^t)\n        uint cumulativeIssuanceFraction = (uint(1e18).sub(power));\n        assert(cumulativeIssuanceFraction <= 1e18); // must be in range [0,1]\n\n        return cumulativeIssuanceFraction;\n    }\n\n    function sendLQTY(address _account, uint _LQTYamount) external override {\n        _requireCallerIsStabilityPool();\n\n        lqtyToken.transfer(_account, _LQTYamount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"CommunityIssuance: caller is not SP\");\n    }\n}\n"
    },
    "contracts/LQTY/CustomDurationLockupContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Interfaces/ILQTYToken.sol\";\n\ncontract CustomDurationLockupContract {\n    using SafeMath for uint;\n\n    // --- Data ---\n    address public deployer;\n    address public beneficiary;\n\n    ILQTYToken public lqtyToken;\n\n    uint public initialEntitlement;\n\n    uint public lockupStartTimeInSeconds;\n    uint public lockupDurationInSeconds;\n\n    // TODO: use an enum for {inactive, active, ended} ? Make a lockup contract non-reusable after\n    // full withdrawal.\n    bool public active;\n\n    // --- Events ---\n\n    event CDLCLocked(uint lockupStartTime);\n    event CDLCUnlockedAndEmptied(uint unlockTime);\n\n    // --- Functions ---\n\n    constructor \n    (\n    address _lqtyTokenAddress, \n    address _beneficiary, \n    uint _initialEntitlement,\n    uint _lockupDurationInSeconds\n    )\n    public \n    {\n        deployer = msg.sender;\n\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\n\n        beneficiary =  _beneficiary;\n        initialEntitlement = _initialEntitlement;\n        lockupDurationInSeconds = _lockupDurationInSeconds;\n    }\n\n    function lockContract() external returns (bool) {\n        _requireCallerIsLockupDeployer();\n        _requireContractIsNotActive();\n        _requireLQTYBalanceAtLeastEqualsEntitlement();\n\n        lockupStartTimeInSeconds = block.timestamp;\n        active = true; \n        emit CDLCLocked(lockupStartTimeInSeconds);\n        return true;\n    }\n\n    function withdrawLQTY() external {\n        _requireCallerIsBeneficiary();\n        _requireContractIsActive();\n        _requireLockupDurationHasPassed();\n        \n        uint LQTYBalance = lqtyToken.balanceOf(address(this));\n        lqtyToken.transfer(msg.sender, LQTYBalance);\n        \n        active = false;\n        emit CDLCUnlockedAndEmptied(block.timestamp);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsLockupDeployer() internal view {\n        require(msg.sender == deployer, \"OYLC: caller is not OYLC deployer\");\n    }\n\n    function _requireCallerIsBeneficiary() internal view {\n        require(msg.sender == beneficiary, \"OYLC: caller is not the beneficiary\");\n    }\n\n    function _requireContractIsActive() internal view {\n        require(active == true, \"CDLC: Contract must be inactive\");\n    }\n\n    function _requireContractIsNotActive() internal view {\n        require(active == false, \"CDLC: Contract must not be active\");\n    }\n\n    function _requireLockupDurationHasPassed() internal view {\n        require(block.timestamp.sub(lockupStartTimeInSeconds) >= lockupDurationInSeconds, \"CDLC: The lockup duration must have passed\");\n    }\n\n    function _requireLQTYBalanceAtLeastEqualsEntitlement() internal view {\n        uint LQTYBalance = lqtyToken.balanceOf(address(this));\n        require(LQTYBalance >= initialEntitlement, \"CDLC: LQTY balance of this CDLC must cover the initial entitlement\");\n    }\n}"
    },
    "contracts/LQTY/LockupContractFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Interfaces/ILockupContractFactory.sol\";\nimport \"./OneYearLockupContract.sol\";\nimport \"./CustomDurationLockupContract.sol\";\nimport \"../Dependencies/console.sol\";\n\ncontract LockupContractFactory is ILockupContractFactory {\n    using SafeMath for uint;\n     \n    // --- Data ---\n    uint constant public ONE_YEAR_IN_SECONDS = 31536000;\n\n    uint public deploymentTime;\n    address public deployer;\n\n    ILQTYToken public lqtyToken;\n    \n    mapping (address => address) public oneYearLockupContractToDeployer;\n    mapping (address => address) public customDurationLockupContractToDeployer;\n\n    // --- Events ---\n\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n    event OYLCDeployed(address _OYLCAddress, address _beneficiary, uint _entitlement);\n    event CDLCDeployed(address _CDLCAddress, address _beneficiary, uint _initialEntitlement);\n    \n    // --- Functions ---\n\n    constructor () public {\n        deploymentTime = block.timestamp;\n        deployer = msg.sender;\n    }\n\n    function setLQTYTokenAddress(address _lqtyTokenAddress) external override {\n        _requireCallerIsFactoryDeployer();\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\n        emit LQTYTokenAddressSet(_lqtyTokenAddress);\n    }\n\n    function deployOneYearLockupContract(address beneficiary, uint initialEntitlement) external override {\n        _requireLQTYAddressIsSet();\n        OneYearLockupContract oneYearLockupContract = new OneYearLockupContract(\n                                                        address(lqtyToken), \n                                                        beneficiary, \n                                                        initialEntitlement);\n\n        oneYearLockupContractToDeployer[address(oneYearLockupContract)] = msg.sender;\n        emit OYLCDeployed(address(oneYearLockupContract), beneficiary, initialEntitlement);\n    }\n\n    function deployCustomDurationLockupContract(address beneficiary, uint initialEntitlement, uint lockupDuration) external override {\n        _requireLQTYAddressIsSet();\n        _requireFactoryIsAtLeastOneYearOld();\n    \n        CustomDurationLockupContract customDurationLockupContract = new CustomDurationLockupContract( \n                                                                        address(lqtyToken), \n                                                                        beneficiary, \n                                                                        initialEntitlement, \n                                                                        lockupDuration);\n\n        customDurationLockupContractToDeployer[address(customDurationLockupContract)] = msg.sender;\n        emit CDLCDeployed(address(customDurationLockupContract),  beneficiary, initialEntitlement);\n    }\n\n    // Simultaneously lock a set of OYLCs that were originally deployed by the caller, through this Factory.\n    function lockOneYearContracts(address[] calldata addresses) external override {\n        for (uint i = 0; i < addresses.length; i++ ) {\n            address addr = addresses[i];\n            OneYearLockupContract oneYearlockupContract = OneYearLockupContract(addr);\n            \n            _requireIsRegisteredOneYearLockup(addr);\n            _requireCallerIsOriginalDeployerofOYLC(addr);\n\n            oneYearlockupContract.lockContract();\n        }\n    }\n\n    // Simultaneously lock a set of CDLCs that were originally deployed by the caller, through this Factory.\n    function lockCustomDurationContracts(address[] calldata addresses) external override {\n        for (uint i = 0; i < addresses.length; i++ ) {\n            address addr = addresses[i];\n            CustomDurationLockupContract customDurationLockupContract = CustomDurationLockupContract(addr);\n            \n            _requireIsRegisteredCustomDurationLockup(addr);\n            _requireCallerIsOriginalDeployerofCDLC(addr);\n\n           customDurationLockupContract.lockContract();\n        }\n    }\n\n    function isRegisteredOneYearLockup(address _contractAddress) external view override returns (bool) {\n        return _isRegisteredOneYearLockup(_contractAddress);\n    }\n\n    function _isRegisteredOneYearLockup(address _contractAddress) internal view returns (bool) {\n        bool isRegistered = oneYearLockupContractToDeployer[_contractAddress] != address(0);\n        return isRegistered;\n    }\n\n    function isRegisteredCustomDurationLockup(address _contractAddress) external view override returns (bool) {\n        return _isRegisteredCustomDurationLockup(_contractAddress);\n    }\n\n    function _isRegisteredCustomDurationLockup(address _contractAddress) internal view returns (bool) {\n        bool isRegistered = customDurationLockupContractToDeployer[_contractAddress] != address(0);\n        return isRegistered;\n    }\n\n    // --- 'require'  functions ---\n\n    function _requireCallerIsFactoryDeployer() internal view {\n        require(msg.sender == deployer, \"LCF: caller is not LCF deployer\");\n    }\n\n    function _requireLQTYAddressIsSet() internal view {\n        require(address(lqtyToken) != address(0), \"LCF: LQTY Address is not set\");\n    }\n\n    function _requireFactoryIsAtLeastOneYearOld() internal view {\n        require(block.timestamp.sub(deploymentTime) >= ONE_YEAR_IN_SECONDS,\n        \"Factory must be at least one year old\");\n    }\n\n    function _requireIsRegisteredOneYearLockup(address _contractAddress) internal view {\n        require(_isRegisteredOneYearLockup(_contractAddress), \n        \"LCF: is not the address of a registered OneYearLockupContract\");\n    }\n\n    function _requireIsRegisteredCustomDurationLockup(address _contractAddress) internal view {\n        require(_isRegisteredCustomDurationLockup(_contractAddress), \n        \"LCF: is not the address of a registered CustomDurationLockupContract\");\n    }\n\n    function _requireCallerIsOriginalDeployerofOYLC(address _contractAddress) internal view {\n        address deployerAddress = oneYearLockupContractToDeployer[_contractAddress];\n        require(deployerAddress == msg.sender,\n        \"LCF: OneYearLockupContract was not deployed by the caller\");\n    }\n\n     function _requireCallerIsOriginalDeployerofCDLC(address _contractAddress) internal view {\n        address deployerAddress = customDurationLockupContractToDeployer[_contractAddress];\n        require(deployerAddress == msg.sender,\n        \"LCF: customDurationLockupContract was not deployed by the caller\");\n    }\n}"
    },
    "contracts/LQTY/OneYearLockupContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Interfaces/ILQTYToken.sol\";\n\ncontract OneYearLockupContract {\n    using SafeMath for uint;\n\n    // --- Data ---\n\n    uint constant public ONE_YEAR_IN_SECONDS = 31536000; \n\n    address public deployer;\n    address public beneficiary;\n\n    ILQTYToken public lqtyToken;\n\n    uint public initialEntitlement;\n\n    uint public lockupStartTime;\n\n    // TODO: use an enum for {inactive, active, ended} ? Make a lockup contract non-reusable after\n    // full withdrawal.\n    bool public active;\n\n    // --- Events ---\n\n    event OYLCLocked(uint lockupStartTime);\n    event OYLCUnlockedAndEmptied(uint unlockTime);\n\n    // --- Functions ---\n\n    constructor \n    (\n        address _lqtyTokenAddress, \n        address _beneficiary, \n        uint _initialEntitlement\n    )\n        public \n    {\n        deployer = msg.sender;\n\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\n\n        beneficiary =  _beneficiary;\n        initialEntitlement = _initialEntitlement;\n    }\n\n    function lockContract() external returns (bool) {\n        _requireCallerIsLockupDeployer();\n        _requireContractIsNotActive();\n        _requireLQTYBalanceAtLeastEqualsEntitlement();\n\n        active = true; \n        lockupStartTime = block.timestamp;\n        emit OYLCLocked(lockupStartTime);\n        return true;\n    }\n\n    function withdrawLQTY() external {\n        _requireCallerIsBeneficiary();\n        _requireContractIsActive();\n        _requireOneYearPassedSinceLockup();\n        \n        active = false;\n\n        uint LQTYBalance = lqtyToken.balanceOf(address(this));\n        lqtyToken.transfer(beneficiary, LQTYBalance);\n        emit OYLCUnlockedAndEmptied(block.timestamp);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsLockupDeployer() internal view {\n        require(msg.sender == deployer, \"OYLC: caller is not OYLC deployer\");\n    }\n\n    function _requireCallerIsBeneficiary() internal view {\n        require(msg.sender == beneficiary, \"OYLC: caller is not the beneficiary\");\n    }\n\n    function _requireContractIsActive() internal view {\n        require(active == true, \"OYLC: Contract must be active\");\n    }\n\n    function _requireContractIsNotActive() internal view {\n        require(active == false, \"OYLC: Contract must not be active\");\n    }\n\n    function _requireOneYearPassedSinceLockup() internal view {\n        require(block.timestamp.sub(lockupStartTime) >= ONE_YEAR_IN_SECONDS, \"OYLC: At least one year since lockup must have passed\");\n    }\n\n    function _requireLQTYBalanceAtLeastEqualsEntitlement() internal view {\n        uint LQTYBalance = lqtyToken.balanceOf(address(this));\n        require(LQTYBalance >= initialEntitlement, \"OYLC: LQTY balance of this OYLC must cover the initial entitlement\");\n    }\n}"
    },
    "contracts/LQTY/LQTYStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Dependencies/Ownable.sol\";\nimport \"../Dependencies/console.sol\";\nimport \"../Interfaces/ILQTYToken.sol\";\nimport \"../Interfaces/ILQTYStaking.sol\";\nimport \"../Dependencies/LiquityMath.sol\";\nimport \"../Interfaces/ILUSDToken.sol\";\n\ncontract LQTYStaking is ILQTYStaking, Ownable {\n    using SafeMath for uint;\n\n    // --- Data ---\n\n    mapping( address => uint) public stakes;\n    uint public totalLQTYStaked;\n\n    uint public F_ETH;  // Running sum of ETH fees per-LQTY-staked\n    uint public F_LUSD; // Running sum of LQTY fees per-LQTY-staked\n\n    // User snapshots of F_ETH and F_LUSD, taken at the point at which their latest deposit was made\n    mapping (address => Snapshot) public snapshots; \n\n    struct Snapshot {\n        uint F_ETH_Snapshot;\n        uint F_LUSD_Snapshot;\n    }\n    \n    ILQTYToken public lqtyToken;\n    ILUSDToken public lusdToken;\n\n    address public troveManagerAddress;\n    address public borrowerOperationsAddress;\n    address public activePoolAddress;\n\n    // --- Events ---\n\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n    event LUSDTokenAddressSet(address _lusdTokenAddress);\n    event TroveManagerAddressSet(address _troveManager);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n    event ActivePoolAddressSet(address _activePoolAddress);\n\n    // --- Functions ---\n\n    function setAddresses\n    (\n        address _lqtyTokenAddress,\n        address _lusdTokenAddress,\n        address _troveManagerAddress, \n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) \n        external \n        onlyOwner \n        override \n    {\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        troveManagerAddress = _troveManagerAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit LQTYTokenAddressSet(_lqtyTokenAddress);\n        emit LQTYTokenAddressSet(_lusdTokenAddress);\n        emit TroveManagerAddressSet(_troveManagerAddress);\n        emit BorrowerOperationsAddressSet(_borrowerOperationsAddress);\n        emit ActivePoolAddressSet(_activePoolAddress);\n\n        _renounceOwnership();\n    }\n\n    // If caller has a pre-existing stake, send any accumulated ETH and LUSD gains to them. \n    function stake(uint _LQTYamount) external override {\n        uint currentStake = stakes[msg.sender];\n\n        uint ETHGain;\n        uint LUSDGain;\n        // Grab any accumulated ETH and LUSD gains from the current stake\n        if (currentStake != 0) {\n            ETHGain = _getPendingETHGain(msg.sender);\n            LUSDGain = _getPendingLUSDGain(msg.sender);\n        }\n    \n       _updateUserSnapshots(msg.sender);\n\n        // Increase user’s stake and total LQTY staked\n        stakes[msg.sender] = currentStake.add(_LQTYamount);\n        totalLQTYStaked = totalLQTYStaked.add(_LQTYamount);\n\n        // Transfer LQTY from caller to this contract\n        lqtyToken.sendToLQTYStaking(msg.sender, _LQTYamount);\n\n        // Send accumulated LUSD and ETH gains to the caller\n        lusdToken.transfer(msg.sender, LUSDGain);\n        _sendETHGainToUser(ETHGain);\n    }\n\n    // Unstake the LQTY and send the it back to the caller, along with their accumulated LUSD & ETH gains. \n    // If requested amount > stake, send their entire stake.\n    function unstake(uint _LQTYamount) external override {\n        uint currentStake = stakes[msg.sender];\n        _requireUserHasStake(currentStake);\n\n        // Grab any accumulated ETH and LUSD gains from the current stake\n        uint ETHGain = _getPendingETHGain(msg.sender);\n        uint LUSDGain = _getPendingLUSDGain(msg.sender);\n        \n        _updateUserSnapshots(msg.sender);\n\n        uint LQTYToWithdraw = LiquityMath._min(_LQTYamount, currentStake);\n\n        // Decrease user's stake and total LQTY staked\n        stakes[msg.sender] = currentStake.sub(LQTYToWithdraw);\n        totalLQTYStaked = totalLQTYStaked.sub(LQTYToWithdraw);  \n\n        // Transfer unstaked LQTY to user\n        lqtyToken.transfer(msg.sender, LQTYToWithdraw);\n\n        // Send accumulated LUSD and ETH gains to the caller\n        lusdToken.transfer(msg.sender, LUSDGain);\n        _sendETHGainToUser(ETHGain);\n    }\n\n    // --- Reward-per-unit-staked increase functions. Called by Liquity core contracts ---\n\n    function increaseF_ETH(uint _ETHFee) external override {\n        _requireCallerIsTroveManager();\n        uint ETHFeePerLQTYStaked;\n     \n        if (totalLQTYStaked > 0) {ETHFeePerLQTYStaked = _ETHFee.mul(1e18).div(totalLQTYStaked);}\n\n        F_ETH = F_ETH.add(ETHFeePerLQTYStaked); \n    }\n\n    function increaseF_LUSD(uint _LUSDFee) external override {\n        _requireCallerIsBorrowerOperations();\n        uint LUSDFeePerLQTYStaked;\n        \n        if (totalLQTYStaked > 0) {LUSDFeePerLQTYStaked = _LUSDFee.mul(1e18).div(totalLQTYStaked);}\n        \n        F_LUSD = F_LUSD.add(LUSDFeePerLQTYStaked);\n    }\n\n    // --- Pending reward functions ---\n\n    function getPendingETHGain(address _user) external view override returns (uint) {\n        return _getPendingETHGain(_user);\n    }\n\n    function _getPendingETHGain(address _user) internal view returns (uint) {\n        uint F_ETH_Snapshot = snapshots[_user].F_ETH_Snapshot;\n        uint ETHGain = stakes[_user].mul(F_ETH.sub(F_ETH_Snapshot)).div(1e18);\n        return ETHGain;\n    }\n\n    function getPendingLUSDGain(address _user) external view override returns (uint) {\n        return _getPendingLUSDGain(_user);\n    }\n\n    function _getPendingLUSDGain(address _user) internal view returns (uint) {\n        uint F_LUSD_Snapshot = snapshots[_user].F_LUSD_Snapshot;\n        uint LUSDGain = stakes[_user].mul(F_LUSD.sub(F_LUSD_Snapshot)).div(1e18);\n        return LUSDGain;\n    }\n\n    // --- Internal helper functions ---\n\n    function _updateUserSnapshots(address _user) internal {\n        snapshots[_user].F_ETH_Snapshot = F_ETH;\n        snapshots[_user].F_LUSD_Snapshot = F_LUSD;\n    }\n\n    function _sendETHGainToUser(uint ETHGain) internal returns (bool) {\n        (bool success, ) = msg.sender.call{value: ETHGain}(\"\");\n        require(success, \"LQTYStaking: Failed to send accumulated ETHGain\");\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, \"LQTYStaking: caller is not TroveM\");\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"LQTYStaking: caller is not BorrowerOps\");\n    }\n\n     function _requireCallerIsActivePool() internal view {\n        require(msg.sender == activePoolAddress, \"LQTYStaking: caller is not ActivePool\");\n    }\n\n    function _requireUserHasStake(uint currentStake) internal pure {  \n        require(currentStake > 0, 'LQTYStaking: User must have a non-zero stake');  \n    }\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n    }\n}\n"
    },
    "contracts/LQTY/LQTYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Interfaces/ILQTYToken.sol\";\nimport \"../Interfaces/ILockupContractFactory.sol\";\nimport \"../Dependencies/console.sol\";\n\n/*\n* Based upon OpenZeppelin's ERC20 contract:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n*  \n* and their EIP2612 (ERC20Permit / ERC712) functionality:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n* \n*\n*  --- Functionality added specific to the LQTYToken ---\n* \n* 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external \n* transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending LUSD directly to a Liquity \n* core contract, when they should rather call the right function.\n*\n* 2) sendToLQTYStaking(): callable only Liquity core contracts, which move LQTY tokens from user -> LQTYStaking contract.\n*\n* 3) Supply hard-capped at 100 million\n*\n* 4) CommunityIssuance and LockupContractFactory addresses set at deployment\n*\n* 5) 2/3 of supply is minted to deployer at deployment\n*\n* 6) 1/3 of supply minted to CommunityIssuance contract at deployment\n* \n* 7) Until one year from deployment:\n* -Deployer may only transfer() tokens to OneYearLockupContracts that have been deployed via & registered in the \n*  LockupContractFactory \n* -approve(), increaseAllowance(), decreaseAllowance() revert when called by the deployer\n* -transferFrom() reverts when deployer is the sender\n* -sendToLQTYStaking() reverts when deployer is sender, blocking the deployer from staking their LQTY.\n* \n* After one year has passed since deployment of the LQTYToken, the restrictions on deployer operations are lifted\n* and the deployer has the same rights as any other address.\n */\n\ncontract LQTYToken is ILQTYToken {\n    using SafeMath for uint256;\n\n    // --- ERC20 Data ---\n\n    string constant internal _NAME = \"LQTY\";\n    string constant internal _SYMBOL = \"LQTY\";\n    string constant internal _VERSION = \"1\";\n    uint8 constant internal  _DECIMALS = 18;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint private _totalSupply;\n\n    // --- EIP 2612 Data ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 constant internal _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping (address => uint256) private _nonces;\n\n    // --- LQTYToken specific data ---\n\n    uint public constant ONE_YEAR_IN_SECONDS = 31536000;  // 60 * 60 * 24 * 365\n    uint internal _100_MILLION = 1e26;  // non-constant, for use with SafeMath\n\n    uint public deploymentStartTime;\n    address public deployer;\n\n    address public immutable communityIssuanceAddress;\n    address public immutable lqtyStakingAddress;\n\n    ILockupContractFactory public lockupContractFactory;\n\n    // --- Events ---\n\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\n    event LQTYStakingAddressSet(address _lqtyStakingAddress);\n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\n\n    // --- Functions ---\n\n    constructor\n    (\n        address _communityIssuanceAddress, \n        address _lqtyStakingAddress,\n        address _lockupFactoryAddress\n    ) \n        public \n    {\n        deployer = msg.sender;\n        deploymentStartTime  = block.timestamp;\n        \n        communityIssuanceAddress = _communityIssuanceAddress;\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lockupContractFactory = ILockupContractFactory(_lockupFactoryAddress);\n        \n        // mint 2/3 to deployer\n        uint deployerEntitlement = _100_MILLION.mul(2).div(3);\n        _mint(msg.sender, deployerEntitlement);\n\n        // mint 1/3 to CommunityIssuance\n        uint communityEntitlement = _100_MILLION.mul(1).div(3);\n        _mint(_communityIssuanceAddress, communityEntitlement);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        // Restrict the deployer's transfers in first year\n        if (_callerIsDeployer() && _isFirstYear()) {\n            _requireRecipientIsRegisteredOYLC(recipient);\n        }\n\n        _requireValidRecipient(recipient);\n\n        // Otherwise, standard transfer functionality\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        if (_isFirstYear()) { _requireCallerIsNotDeployer(); }\n\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        if (_isFirstYear()) { _requireSenderIsNotDeployer(sender); }\n        \n        _requireValidRecipient(recipient);\n\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n        if (_isFirstYear()) { _requireCallerIsNotDeployer(); }\n        \n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n        if (_isFirstYear()) { _requireCallerIsNotDeployer(); }\n        \n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function sendToLQTYStaking(address _sender, uint256 _amount) external override {\n        _requireCallerIsLQTYStaking();\n        if (_isFirstYear()) { _requireSenderIsNotDeployer(_sender); }\n        _transfer(_sender, lqtyStakingAddress, _amount);\n    }\n\n    // --- EIP 2612 functionality ---\n\n    function domainSeparator() public view override returns (bytes32) {    \n        return keccak256(abi.encode( \n               keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n               keccak256(bytes(_NAME)), \n               keccak256(bytes(_VERSION)), \n               _chainID(),address(this)));\n    }\n\n    function permit\n    (\n        address owner, \n        address spender, \n        uint amount, \n        uint deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) \n        external \n        override \n    {            \n        require(deadline == 0 || deadline >= now, 'LUSD: Signature has expired');\n        bytes32 digest = keccak256(abi.encodePacked(uint16(0x1901), \n                         domainSeparator(), keccak256(abi.encode(\n                         _PERMIT_TYPEHASH, owner, spender, amount, \n                         _nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && \n                recoveredAddress == owner, 'LUSD: Recovered address from the sig is not the owner');\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) { // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    function _chainID() private pure returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    // --- Internal operations ---\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // --- Helper functions ---\n\n    function _callerIsDeployer() internal view returns (bool) {\n        return (msg.sender == deployer);\n    }\n\n    function _isFirstYear() internal view returns (bool) {\n        return (block.timestamp.sub(deploymentStartTime) < ONE_YEAR_IN_SECONDS);\n    }\n\n    // --- 'require' functions ---\n    \n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && \n            _recipient != address(this),\n            \"LQTY: Cannot transfer tokens directly to the LQTY token contract or the zero address\"\n        );\n        require(\n            _recipient != communityIssuanceAddress &&\n            _recipient != lqtyStakingAddress,\n            \"LQTY: Cannot transfer tokens directly to the community issuance or staking contract\"\n        );\n    }\n\n    function _requireRecipientIsRegisteredOYLC(address _recipient) internal view {\n        require(lockupContractFactory.isRegisteredOneYearLockup(_recipient), \n        \"LQTYToken: recipient must be a OYLC registered in the Factory\");\n    }\n\n    function _requireSenderIsNotDeployer(address _sender) internal view {\n        require(_sender != deployer, \"LQTYToken: sender must not be the deployer\");\n    }\n\n    function _requireCallerIsNotDeployer() internal view {\n        require(!_callerIsDeployer(), \"LQTYToken: caller must not be the deployer\");\n    }\n\n    function _requireCallerIsLQTYStaking() internal view {\n         require(msg.sender == lqtyStakingAddress, \"LQTYToken: caller must be the LQTYStaking contract\");\n    }\n\n    // --- Optional functions ---\n\n    function name() external view override returns (string memory) {\n        return _NAME;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _SYMBOL;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _DECIMALS;\n    }\n\n    function version() external view override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external view override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}"
    },
    "contracts/LUSDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/console.sol\";\n/*\n*\n* Based upon OpenZeppelin's ERC20 contract:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n*  \n* and their EIP2612 (ERC20Permit / ERC712) functionality:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n* \n*\n* --- Functionality added specific to the LUSDToken ---\n* \n* 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external \n* transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending LUSD directly to a Liquity \n* core contract, when they should rather call the right function. \n*\n* 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move LUSD tokens between Liquity <-> user.\n*/\n\ncontract LUSDToken is ILUSDToken {\n    using SafeMath for uint256;\n    \n    uint256 private _totalSupply;\n    string constant internal _NAME = \"LUSD Stablecoin\";\n    string constant internal _SYMBOL = \"LUSD\";\n    string constant internal _VERSION = \"1\";\n    uint8 constant internal _DECIMALS = 18;\n    \n    // --- Data for EIP2612 ---\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 constant internal _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping (address => uint256) private _nonces;\n    \n    // User data for LUSD token\n    mapping (address => uint256) private _balances;\n     mapping (address => mapping (address => uint256)) private _allowances;  \n    \n    // --- Addresses ---\n    address public immutable troveManagerAddress;\n    address public immutable stabilityPoolAddress;\n    address public immutable borrowerOperationsAddress;\n    \n    constructor\n    ( \n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress\n    ) \n        public \n    {  \n        troveManagerAddress = _troveManagerAddress;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        stabilityPoolAddress = _stabilityPoolAddress;\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;        \n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBorrowerOperations();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(address _sender,  address _poolAddress, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {\n        _requireCallerIsTroveMorSP();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    // --- EIP 2612 Functionality ---\n\n    function domainSeparator() public view override returns (bytes32) {    \n        return keccak256(abi.encode( \n               keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n               keccak256(bytes(_NAME)), \n               keccak256(bytes(_VERSION)), \n               _chainID(),address(this)));\n    }\n\n    function permit\n    (\n        address owner, \n        address spender, \n        uint amount, \n        uint deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) \n        external \n        override \n    {            \n        require(deadline == 0 || deadline >= now, 'LUSD: Signature has expired');\n        bytes32 digest = keccak256(abi.encodePacked(uint16(0x1901), \n                         domainSeparator(), keccak256(abi.encode(\n                         _PERMIT_TYPEHASH, owner, spender, amount, \n                         _nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && \n                recoveredAddress == owner, 'LUSD: Recovered address from the sig is not the owner');\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) { // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    function _chainID() private pure returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    // --- Internal operations ---\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        assert(sender != address(0));\n        assert(recipient != address(0));\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        assert(account != address(0));\n        \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        assert(owner != address(0));\n        assert(spender != address(0));\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && \n            _recipient != address(this),\n            \"LUSD: Cannot transfer tokens directly to the LUSD token contract or the zero address\"\n        );\n        require(\n            _recipient != stabilityPoolAddress && \n            _recipient != troveManagerAddress && \n            _recipient != borrowerOperationsAddress, \n            \"LUSD: Cannot transfer tokens directly to the StabilityPool, TroveManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"LUSDToken: Caller is not BorrowerOperations\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress ||\n            msg.sender == stabilityPoolAddress,\n            \"LUSD: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"LUSD: Caller is not the StabilityPool\");\n    }\n\n    function _requireCallerIsTroveMorSP() internal view {\n        require(\n            msg.sender == troveManagerAddress || msg.sender == stabilityPoolAddress,\n            \"LUSD: Caller is neither TroveManager nor StabilityPool\");\n    }\n\n    // --- Optional functions ---\n\n    function name() external view override returns (string memory) {\n        return _NAME;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _SYMBOL;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _DECIMALS;\n    }\n\n    function version() external view override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external view override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedTroves.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\ncontract MultiTroveGetter {\n    struct CombinedTroveData {\n        address owner;\n\n        uint debt;\n        uint coll;\n        uint stake;\n\n        uint snapshotETH;\n        uint snapshotLUSDDebt;\n    }\n\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\n    ISortedTroves public sortedTroves;\n\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) public {\n        troveManager = _troveManager;\n        sortedTroves = _sortedTroves;\n    }\n\n    function getMultipleSortedTroves(int _startIdx, uint _count)\n        external view returns (CombinedTroveData[] memory _troves)\n    {\n        uint startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)\n        internal view returns (CombinedTroveData[] memory _troves)\n    {\n        address currentTroveowner = sortedTroves.getFirst();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)\n        internal view returns (CombinedTroveData[] memory _troves)\n    {\n        address currentTroveowner = sortedTroves.getLast();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */,\n                /* arrayIndex */\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotLUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n    }\n}\n"
    },
    "contracts/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IPool.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\ncontract TroveManager is LiquityBase, Ownable, ITroveManager {\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IPool public activePool;\n\n    IPool public defaultPool;\n\n    IStabilityPool public stabilityPool;\n\n    ICollSurplusPool collSurplusPool;\n\n    ILUSDToken public lusdToken;\n\n    IPriceFeed public priceFeed;\n\n    ILQTYStaking public lqtyStaking;\n    address public lqtyStakingAddress;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint constant public SECONDS_IN_ONE_MINUTE = 60;\n    uint constant public MINUTE_DECAY_FACTOR = 999832508430720967;  // 18 digit decimal. Corresponds to an hourly decay factor of 0.99\n\n    /* \n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption. \n    * Corresponds to (1 / ALPHA) in the white paper. \n    */\n    uint constant public BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new LUSD issuance) \n    uint public lastFeeOperationTime;\n\n    enum Status { nonExistent, active, closed }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping (address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n    * L_ETH and L_LUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n    *\n    * An ETH gain of ( stake * [L_ETH - L_ETH(0)] )\n    * A LUSDDebt increase  of ( stake * [L_LUSDDebt - L_LUSDDebt(0)] )\n    *\n    * Where L_ETH(0) and L_LUSDDebt(0) are snapshots of L_ETH and L_LUSDDebt for the active Trove taken at the instant the stake was made\n    */\n    uint public L_ETH;\n    uint public L_LUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the ETH and LUSD snapshots for a given active trove\n    struct RewardSnapshot { uint ETH; uint LUSDDebt;}\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastETHError_Redistribution;\n    uint public lastLUSDDebtError_Redistribution;\n\n    /* \n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: \"CompilerError: Stack too deep\". \n    **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint LUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingLUSDInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint LUSDGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalLUSDGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        address partialAddr;\n        uint partialNewDebt;\n        uint partialNewColl;\n        address partialUpperHint;\n        address partialLowerHint;\n    }\n\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint totalLUSDToRedeem;\n        uint totalETHDrawn;\n        uint ETHFee;\n        uint ETHToSendToRedeemer;\n        uint decayedBaseRate;\n    }\n\n    struct SingleRedemptionValues {\n        uint LUSDLot;\n        uint ETHLot;\n    }\n\n    // --- Events ---\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        partiallyLiquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    event TroveCreated(address indexed _borrower, uint _arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint _stake, TroveManagerOperation _operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, TroveManagerOperation _operation);\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _lqtyStakingAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IPool(_activePoolAddress);\n        defaultPool = IPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        lqtyStakingAddress = _lqtyStakingAddress;\n        lqtyStaking = ILQTYStaking(_lqtyStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit LQTYStakingAddressChanged(_lqtyStakingAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. \n    function liquidate(address _borrower) external override {\n        _requireTroveisActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(address _borrower, uint _LUSDInStabPool) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n        _removeStake(_borrower);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        uint collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        (V.debtToOffset,\n        V.collToSendToSP,\n        V.debtToRedistribute,\n        V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, collToLiquidate, _LUSDInStabPool);\n\n        _closeTrove(_borrower);\n        emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\n\n        return V;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(address _borrower, uint _ICR, uint _LUSDInStabPool, uint _TCR) internal returns (LiquidationValues memory V) {\n        LocalVariables_InnerSingleLiquidateFunction memory L;\n        \n        if (TroveOwners.length <= 1) { return V; } // don't liquidate if last trove\n\n        (V.entireTroveDebt,\n        V.entireTroveColl,\n        L.pendingDebtReward,\n        L.pendingCollReward) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(L.pendingDebtReward, L.pendingCollReward);\n\n        V.collGasCompensation = _getCollGasCompensation(V.entireTroveColl);\n        // In case of a partial liquidation, V.LUSDGasCompensation will be overwritten to zero, in the third branch below\n        V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n        L.collToLiquidate = V.entireTroveColl.sub(V.collGasCompensation);\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _removeStake(_borrower);\n\n            V.debtToOffset = 0;\n            V.collToSendToSP = 0;\n            V.debtToRedistribute = V.entireTroveDebt;\n            V.collToRedistribute = L.collToLiquidate;\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _removeStake(_borrower);\n\n            (V.debtToOffset,\n            V.collToSendToSP,\n            V.debtToRedistribute,\n            V.collToRedistribute) = _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n            emit TroveLiquidated(_borrower, V.entireTroveDebt, V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n\n        /* \n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n        * and there is LUSD in the Stability Pool, only offset it as much as possible, with no redistribution.\n        */\n        } else if ((_ICR >= MCR) && (_ICR < _TCR)) {\n            assert(_LUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            \n            V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt, V.entireTroveColl, _LUSDInStabPool);\n\n            _closeTrove(_borrower);\n        }\n        else { // if (_ICR >= _TCR)\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return V;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be \n    * redistributed to active troves. \n    */\n    function _getOffsetAndRedistributionVals\n    (\n        uint _debt,\n        uint _coll,\n        uint _LUSDInStabPool\n    )\n        internal\n        pure\n        returns (uint debtToOffset, uint collToSendToSP, uint debtToRedistribute, uint collToRedistribute)\n    {\n        if (_LUSDInStabPool > 0) {\n        /* \n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n        * between all active troves.\n        *\n        *  If the trove's debt is larger than the deposited LUSD in the Stability Pool:\n        *\n        *  - Offset an amount of the trove's debt equal to the LUSD in the Stability Pool\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n        *\n        */\n            debtToOffset = LiquityMath._min(_debt, _LUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n    *  If it is a full offset, get its offset coll/debt and ETH gas comp, and close the trove.\n    *\n    * If it is a partial liquidation, get its offset coll/debt and ETH gas comp, and its new coll/debt, and its re-insertion hints.\n    */\n    function _getFullOrPartialOffsetVals\n    (\n        address _borrower,\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _LUSDInStabPool\n    )\n        internal\n        returns (LiquidationValues memory V)\n    {\n        V.entireTroveDebt = _entireTroveDebt;\n        V.entireTroveColl = _entireTroveColl;\n\n        // When Stability Pool can fully absorb the trove's debt, perform a full offset\n        if (_entireTroveDebt <= _LUSDInStabPool) {\n            V.collGasCompensation = _getCollGasCompensation(_entireTroveColl);\n            V.LUSDGasCompensation = LUSD_GAS_COMPENSATION;\n\n            V.debtToOffset = _entireTroveDebt;\n            V.collToSendToSP = _entireTroveColl.sub(V.collGasCompensation);\n            V.debtToRedistribute = 0;\n            V.collToRedistribute = 0;\n\n            emit TroveLiquidated(_borrower, _entireTroveDebt, _entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\n        }\n        /* \n        * When trove's debt is greater than the Stability Pool, perform a partial liquidation: offset as much as possible,\n        * and do not redistribute the remainder. The trove remains active, with a reduced collateral and debt.\n        *\n        * ETH gas compensation is based on and drawn from the collateral fraction that corresponds to the partial offset. \n        * LUSD gas compensation is left untouched. \n        *\n        * Since ETH gas comp is drawn purely from the *liquidated* portion, the trove is left with the same ICR as before the \n        * liquidation.\n        */\n        else { // if (_entireTroveDebt > _LUSDInStabPool)\n            // Remaining debt in the trove is lower-bounded by the trove's gas compensation\n            V.partialNewDebt = LiquityMath._max(_entireTroveDebt.sub(_LUSDInStabPool), LUSD_GAS_COMPENSATION);\n          \n            V.debtToOffset = _entireTroveDebt.sub(V.partialNewDebt);\n\n            uint collFraction = _entireTroveColl.mul(V.debtToOffset).div(_entireTroveDebt);\n            V.collGasCompensation = _getCollGasCompensation(collFraction);\n          \n            V.LUSDGasCompensation = 0;  // LUSD gas compensation remains untouched\n\n            V.collToSendToSP = collFraction.sub(V.collGasCompensation);\n            V.collToRedistribute = 0;\n            V.debtToRedistribute = 0;\n\n            V.partialAddr = _borrower;\n            V.partialNewColl = _entireTroveColl.sub(collFraction);\n\n            // Get the partial trove's neighbours, so we can re-insert it later to the same position\n            V.partialUpperHint = sortedTroves.getPrev(_borrower);  \n            V.partialLowerHint = sortedTroves.getNext(_borrower);\n        }\n    }\n\n    /* \n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\n    */\n    function liquidateTroves(uint _n) external override {\n        LocalVariables_OuterLiquidationFunction memory L;\n\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (L.recoveryModeAtStart == true) {\n            T = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(L.price, L.LUSDInStabPool, _n);\n        } else { // if L.recoveryModeAtStart == false\n            T = _getTotalsFromLiquidateTrovesSequence_NormalMode(L.price, L.LUSDInStabPool, _n);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /*\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n        \n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) {break;}\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            L.i++;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        uint _n\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        L.i = 0;\n        while (L.i < _n) {\n            L.user = sortedTroves.getLast();\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\n\n            // Break the loop if it reaches the first Trove in the sorted list\n            if (L.user == sortedTroves.getFirst()) { break; }\n            L.i++;\n        }\n    }\n\n    /* \n    * Attempt to liquidate a custom list of troves provided by the caller. The liquidation sequence stops if\n    * a partial liquidation is performed, so it's up to the caller to order the troves in the _troveArray parameter.\n    */\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\n        require(_troveArray.length != 0, \"TroveManager: Calldata address array must not be empty\");\n\n        LocalVariables_OuterLiquidationFunction memory L;\n        LiquidationTotals memory T;\n\n        L.price = priceFeed.getPrice();\n        L.LUSDInStabPool = stabilityPool.getTotalLUSDDeposits();\n        L.recoveryModeAtStart = checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (L.recoveryModeAtStart == true) {\n           T = _getTotalFromBatchLiquidate_RecoveryMode(L.price, L.LUSDInStabPool, _troveArray);\n        } else {  //  if L.recoveryModeAtStart == false\n            T = _getTotalsFromBatchLiquidate_NormalMode(L.price, L.LUSDInStabPool, _troveArray);\n        }\n\n        // Move liquidated ETH and LUSD to the appropriate pools\n        stabilityPool.offset(T.totalDebtToOffset, T.totalCollToSendToSP);\n        _redistributeDebtAndColl(T.totalDebtToRedistribute, T.totalCollToRedistribute);\n\n        // Update system snapshots and the final partially liquidated trove, if there is one\n        _updateSystemSnapshots_excludeCollRemainder(T.partialNewColl.add(T.totalCollGasCompensation));\n        _updatePartiallyLiquidatedTrove(T.partialAddr, T.partialNewDebt, T.partialNewColl, T.partialUpperHint, T. partialLowerHint, L.price);\n\n        L.liquidatedDebt = T.totalDebtInSequence.sub(T.partialNewDebt);\n        L.liquidatedColl = T.totalCollInSequence.sub(T.totalCollGasCompensation).sub(T.partialNewColl);\n        emit Liquidation(L.liquidatedDebt, L.liquidatedColl, T.totalCollGasCompensation, T.totalLUSDGasCompensation);\n\n        // Send gas compensation to caller\n        _sendGasCompensation(msg.sender, T.totalLUSDGasCompensation, T.totalCollGasCompensation);\n    }\n\n    /* \n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n    */\n    function _getTotalFromBatchLiquidate_RecoveryMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray)\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n        L.backToNormalMode = false;\n        L.entireSystemDebt = activePool.getLUSDDebt().add(defaultPool.getLUSDDebt());\n        L.entireSystemColl = activePool.getETH().add(defaultPool.getETH());\n\n        L.i = 0;\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.backToNormalMode == false) {\n\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }\n\n                uint TCR = LiquityMath._computeCR(L.entireSystemColl, L.entireSystemDebt, _price);\n\n                V = _liquidateRecoveryMode(L.user, L.ICR, L.remainingLUSDInStabPool, TCR);\n\n                // Update aggregate trackers\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n                L.entireSystemDebt = L.entireSystemDebt.sub(V.debtToOffset);\n                L.entireSystemColl = L.entireSystemColl.sub(V.collToSendToSP);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n\n                // Break the loop if it was a partial liquidation\n                if (V.partialAddr != address(0)) { break; }\n\n                L.backToNormalMode = !_checkPotentialRecoveryMode(L.entireSystemColl, L.entireSystemDebt, _price);\n            }\n\n            else if (L.backToNormalMode == true && L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            \n            } else continue; // In Normal Mode skip troves with ICR >= MCR  \n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode\n    (\n        uint _price,\n        uint _LUSDInStabPool,\n        address[] memory _troveArray\n    )\n        internal\n        returns(LiquidationTotals memory T)\n    {\n        LocalVariables_LiquidationSequence memory L;\n        LiquidationValues memory V;\n\n        L.remainingLUSDInStabPool = _LUSDInStabPool;\n\n        for (L.i = 0; L.i < _troveArray.length; L.i++) {\n            L.user = _troveArray[L.i];\n            L.ICR = getCurrentICR(L.user, _price);\n\n            if (L.ICR < MCR) {\n                V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);\n                L.remainingLUSDInStabPool = L.remainingLUSDInStabPool.sub(V.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                T = _addLiquidationValuesToTotals(T, V);\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(LiquidationTotals memory T1, LiquidationValues memory V)\n    internal pure returns(LiquidationTotals memory T2) {\n\n        // Tally all the values with their respective running totals\n        T2.totalCollGasCompensation = T1.totalCollGasCompensation.add(V.collGasCompensation);\n        T2.totalLUSDGasCompensation = T1.totalLUSDGasCompensation.add(V.LUSDGasCompensation);\n        T2.totalDebtInSequence = T1.totalDebtInSequence.add(V.entireTroveDebt);\n        T2.totalCollInSequence = T1.totalCollInSequence.add(V.entireTroveColl);\n        T2.totalDebtToOffset = T1.totalDebtToOffset.add(V.debtToOffset);\n        T2.totalCollToSendToSP = T1.totalCollToSendToSP.add(V.collToSendToSP);\n        T2.totalDebtToRedistribute = T1.totalDebtToRedistribute.add(V.debtToRedistribute);\n        T2.totalCollToRedistribute = T1.totalCollToRedistribute.add(V.collToRedistribute);\n\n        // Assign the address of the partially liquidated trove, and its new debt and coll values\n        T2.partialAddr = V.partialAddr;\n        T2.partialNewDebt = V.partialNewDebt;\n        T2.partialNewColl = V.partialNewColl;\n        T2.partialUpperHint = V.partialUpperHint;\n        T2.partialLowerHint = V.partialLowerHint;\n\n        return T2;\n    }\n\n    // Update the properties of the partially liquidated trove, and insert it back to the list\n    function _updatePartiallyLiquidatedTrove\n    (\n        address _borrower, \n        uint _newDebt, \n        uint _newColl, \n        address _upperHint,\n        address _lowerHint,\n        uint _price\n    ) \n        internal \n    {\n        if ( _borrower == address(0)) { return; }\n\n        Troves[_borrower].debt = _newDebt;\n        Troves[_borrower].coll = _newColl;\n        Troves[_borrower].status = Status.active;\n\n        _updateTroveRewardSnapshots(_borrower);\n        _updateStakeAndTotalStakes(_borrower);\n\n        uint ICR = getCurrentICR(_borrower, _price);\n\n        /* \n        * Insert to sorted list and add to TroveOwners array. The partially liquidated trove has the same\n        * ICR as it did before the liquidation, so insertion is O(1): in principle, its ICR does not change.\n        * In practice, due to rounding error, its ICR can change slightly - so re-insert, with its previous neighbours\n        * as hints.\n        */\n        sortedTroves.insert(_borrower, ICR, _price, _upperHint, _lowerHint);\n        _addTroveOwnerToArray(_borrower);\n        emit TroveUpdated(_borrower, _newDebt, _newColl, Troves[_borrower].stake, TroveManagerOperation.partiallyLiquidateInRecoveryMode);\n    }\n\n    function _sendGasCompensation(address _liquidator, uint _LUSD, uint _ETH) internal {\n        if (_LUSD > 0) {\n            lusdToken.returnFromPool(GAS_POOL_ADDRESS, _liquidator, _LUSD);\n        }\n\n        if (_ETH > 0) {\n            activePool.sendETH(_liquidator, _ETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(uint _LUSD, uint _ETH) internal {\n        defaultPool.decreaseLUSDDebt(_LUSD);\n        activePool.increaseLUSDDebt(_LUSD);\n        defaultPool.sendETH(address(activePool), _ETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for LUSD up to _maxLUSDamount\n    function _redeemCollateralFromTrove(\n        address _borrower,\n        uint _maxLUSDamount,\n        uint _price,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    )\n        internal returns (SingleRedemptionValues memory V)\n    {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the gas compensation\n        V.LUSDLot = LiquityMath._min(_maxLUSDamount, Troves[_borrower].debt.sub(LUSD_GAS_COMPENSATION));\n\n        // Get the ETHLot of equivalent value in USD\n        V.ETHLot = V.LUSDLot.mul(1e18).div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the LUSD lot and corresponding ETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(V.LUSDLot);\n        uint newColl = (Troves[_borrower].coll).sub(V.ETHLot);\n\n        if (newDebt == LUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the gas compensation), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower);\n            _redeemCloseTrove(_borrower, LUSD_GAS_COMPENSATION, newColl);\n\n        } else {\n            uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n\n            // Check if the provided hint is fresh. If not, we bail since trying to reinsert without a good hint will almost\n            // certainly result in running out of gas.\n            if (newICR != _partialRedemptionHintICR) {\n                V.LUSDLot = 0;\n                V.ETHLot = 0;\n                return V;\n            }\n\n            sortedTroves.reInsert(_borrower, newICR, _price, _partialRedemptionHint, _partialRedemptionHint);\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n        }\n        emit TroveUpdated(\n            _borrower,\n            newDebt, newColl,\n            Troves[_borrower].stake,\n            TroveManagerOperation.redeemCollateral\n        );\n        return V;\n    }\n\n    /* \n    * Called when a full redemption occurs, and closes the trove.\n    * The redeemer swaps (debt - 10) LUSD for (debt - 10) worth of ETH, so the 10 LUSD gas compensation left corresponds to the remaining debt.\n    * In order to close the trove, the 10 LUSD gas compensation is burned, and 10 debt is removed from the active pool.\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n    * Any surplus ETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n    */ \n    function _redeemCloseTrove(address _borrower, uint _LUSD, uint _ETH) internal {\n        lusdToken.burn(GAS_POOL_ADDRESS, _LUSD);\n        // Update Active Pool LUSD, and send ETH to account\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        // send ETH from Active Pool to CollSurplus Pool\n        collSurplusPool.accountSurplus(_borrower, _ETH);\n        activePool.sendETH(address(collSurplusPool), _ETH);\n    }\n\n    function _isValidFirstRedemptionHint(address _firstRedemptionHint, uint _price) internal view returns (bool) {\n        if (_firstRedemptionHint == address(0) ||\n            !sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = sortedTroves.getNext(_firstRedemptionHint);\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _LUSDamount LUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    *\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by \n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    * \n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to \n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” \n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode \n    * costs can vary.\n    * \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. \n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position \n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    * \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining LUSD amount, which they can attempt\n    * to redeem later.\n    */\n    function redeemCollateral(\n        uint _LUSDamount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n        external\n        override\n    {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint defaultedDebt = defaultPool.getLUSDDebt();\n\n        RedemptionTotals memory T;\n\n        _requireAmountGreaterThanZero(_LUSDamount);\n        _requireLUSDBalanceCoversRedemption(msg.sender, _LUSDamount);\n\n        // Confirm redeemer's balance is less than total systemic debt\n        assert(lusdToken.balanceOf(msg.sender) <= (activeDebt.add(defaultedDebt)));\n\n        uint remainingLUSD = _LUSDamount;\n        uint price = priceFeed.getPrice();\n        address currentBorrower;\n\n        if (_isValidFirstRedemptionHint(_firstRedemptionHint, price)) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, price) < MCR) {\n                currentBorrower = sortedTroves.getPrev(currentBorrower);\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of LUSD is exchanged for collateral\n        if (_maxIterations == 0) { _maxIterations = uint(-1); }\n        while (currentBorrower != address(0) && remainingLUSD > 0 && _maxIterations > 0) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = sortedTroves.getPrev(currentBorrower);\n\n            _applyPendingRewards(currentBorrower);\n\n            SingleRedemptionValues memory V = _redeemCollateralFromTrove(\n                currentBorrower,\n                remainingLUSD,\n                price,\n                _partialRedemptionHint,\n                _partialRedemptionHintICR\n            );\n\n            if (V.LUSDLot == 0) break; // Partial redemption hint got out-of-date, therefore we could not redeem from the last Trove\n\n            T.totalLUSDToRedeem  = T.totalLUSDToRedeem.add(V.LUSDLot);\n            T.totalETHDrawn = T.totalETHDrawn.add(V.ETHLot);\n\n            remainingLUSD = remainingLUSD.sub(V.LUSDLot);\n            currentBorrower = nextUserToCheck;\n        }\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption\n        _updateBaseRateFromRedemption(T.totalETHDrawn, price);\n\n        // Calculate the ETH fee and send it to the LQTY staking contract\n        T.ETHFee = _getRedemptionFee(T.totalETHDrawn);\n        activePool.sendETH(lqtyStakingAddress, T.ETHFee);\n        lqtyStaking.increaseF_ETH(T.ETHFee);\n\n        T.ETHToSendToRedeemer = T.totalETHDrawn.sub(T.ETHFee);\n\n        // Burn the total LUSD that is cancelled with debt, and send the redeemed ETH to msg.sender\n        _activePoolRedeemCollateral(msg.sender, T.totalLUSDToRedeem, T.ETHToSendToRedeemer);\n\n        emit Redemption(_LUSDamount, T.totalLUSDToRedeem, T.totalETHDrawn, T.ETHFee);\n    }\n\n    // Burn the received LUSD, transfer the redeemed ETH to _redeemer and updates the Active Pool\n    function _activePoolRedeemCollateral(address _redeemer, uint _LUSD, uint _ETH) internal {\n        // Update Active Pool LUSD, and send ETH to account\n        lusdToken.burn(_redeemer, _LUSD);\n        activePool.decreaseLUSDDebt(_LUSD);\n\n        activePool.sendETH(_redeemer, _ETH);\n    }\n\n    // --- Helper functions ---\n\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower, uint _price) public view override returns (uint) {\n        uint pendingETHReward = getPendingETHReward(_borrower);\n        uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n        uint currentETH = Troves[_borrower].coll.add(pendingETHReward);\n        uint currentLUSDDebt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n        uint ICR = LiquityMath._computeCR(currentETH, currentLUSDDebt, _price);\n        return ICR;\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(_borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveisActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingETHReward = getPendingETHReward(_borrower);\n            uint pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(pendingETHReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingLUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(pendingLUSDDebtReward, pendingETHReward);\n\n            emit TroveUpdated(\n                _borrower, \n                Troves[_borrower].debt, \n                Troves[_borrower].coll, \n                Troves[_borrower].stake, \n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_ETH and L_LUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n       return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].ETH = L_ETH;\n        rewardSnapshots[_borrower].LUSDDebt = L_LUSDDebt;\n    }\n\n    // Get the borrower's pending accumulated ETH reward, earned by their stake\n    function getPendingETHReward(address _borrower) public view override returns (uint) {\n        uint snapshotETH = rewardSnapshots[_borrower].ETH;\n        uint rewardPerUnitStaked = L_ETH.sub(snapshotETH);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingETHReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingETHReward;\n    }\n\n     // Get the borrower's pending accumulated LUSD reward, earned by their stake\n    function getPendingLUSDDebtReward(address _borrower) public view override returns (uint) {\n        uint snapshotLUSDDebt = rewardSnapshots[_borrower].LUSDDebt;\n        uint rewardPerUnitStaked = L_LUSDDebt.sub(snapshotLUSDDebt);\n\n        if ( rewardPerUnitStaked == 0 ) { return 0; }\n\n        uint stake =  Troves[_borrower].stake;\n\n        uint pendingLUSDDebtReward = stake.mul(rewardPerUnitStaked).div(1e18);\n\n        return pendingLUSDDebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /* \n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards \n        */\n        return (rewardSnapshots[_borrower].ETH < L_ETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint debt, uint coll, uint pendingLUSDDebtReward, uint pendingETHReward)\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingLUSDDebtReward = getPendingLUSDDebtReward(_borrower);\n        pendingETHReward = getPendingETHReward(_borrower);\n\n        debt = debt.add(pendingLUSDDebtReward);\n        coll = coll.add(pendingETHReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*  \n            * The following assert() holds true because:\n            * - The system always contains >= 1 trove \n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated, \n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(uint _debt, uint _coll) internal {\n        if (_debt == 0) { return; }\n\n        /* \n        * Add distributed coll and debt rewards-per-unit-staked to the running totals.\n        * Division uses a \"feedback\" error correction, to keep the cumulative error in\n        * the  L_ETH and L_LUSDDebt state variables low. \n        */\n        uint ETHNumerator = _coll.mul(1e18).add(lastETHError_Redistribution);\n        uint LUSDDebtNumerator = _debt.mul(1e18).add(lastLUSDDebtError_Redistribution);\n\n        uint ETHRewardPerUnitStaked = ETHNumerator.div(totalStakes);\n        uint LUSDDebtRewardPerUnitStaked = LUSDDebtNumerator.div(totalStakes);\n\n        lastETHError_Redistribution = ETHNumerator.sub(ETHRewardPerUnitStaked.mul(totalStakes));\n        lastLUSDDebtError_Redistribution = LUSDDebtNumerator.sub(LUSDDebtRewardPerUnitStaked.mul(totalStakes));\n\n        L_ETH = L_ETH.add(ETHRewardPerUnitStaked);\n        L_LUSDDebt = L_LUSDDebt.add(LUSDDebtRewardPerUnitStaked);\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        activePool.decreaseLUSDDebt(_debt);\n        defaultPool.increaseLUSDDebt(_debt);\n        activePool.sendETH(address(defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower);\n    }\n\n    function _closeTrove(address _borrower) internal {\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = Status.closed;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].ETH = 0;\n        rewardSnapshots[_borrower].LUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /* \n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. \n    * Used in a liquidation sequence.\n    *\n    * The calculation excludes two portions of collateral that are in the ActivePool: \n    *\n    * 1) the total ETH gas compensation from the liquidation sequence\n    * 2) The remaining collateral in a partially liquidated trove (if one occurred)\n    *\n    * The ETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    *\n    * The partially liquidated trove's remaining collateral stays in the ActivePool, but it is excluded here so the system \n    * can take snapshots before the partially liquidated trove's stake is updated (based on these snapshots). This ensures\n    * the partial's new stake doesn't double-count its own remaining collateral.\n    *\n    */\n    function _updateSystemSnapshots_excludeCollRemainder(uint _collRemainder) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(liquidatedColl);\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum 10 LUSD\n        debt. 3e31 LUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n    \n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /* \n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index. \n    */\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        require(Troves[_borrower].status == Status.closed, \"TroveManager: Trove is still active\");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function checkRecoveryMode() public view override returns (bool) {\n        uint TCR = getTCR();\n\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an ETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    )\n        internal\n        pure\n    returns (bool)\n    {\n        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        if (TCR < CCR) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function getTCR() public view override returns (uint TCR) {\n        uint price = priceFeed.getPrice();\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, price);\n\n        return TCR;\n    }\n\n    function getEntireSystemColl() public view override returns (uint entireSystemColl) {\n        uint activeColl = activePool.getETH();\n        uint liquidatedColl = defaultPool.getETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view override returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    // --- Redemption fee functions ---\n\n    /* \n    * This function has two impacts on the baseRate state variable:\n    * 1) decays the baseRate based on time passed since last redemption or LUSD borrowing operation.\n    * then,\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n    */\n    function _updateBaseRateFromRedemption(uint _ETHDrawn,  uint _price) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        uint activeDebt = activePool.getLUSDDebt();\n        uint closedDebt = defaultPool.getLUSDDebt();\n        uint totalLUSDSupply = activeDebt.add(closedDebt);\n\n        /* Convert the drawn ETH back to LUSD at face value rate (1 LUSD:1 USD), in order to get\n        * the fraction of total supply that was redeemed at face value. */\n        uint redeemedLUSDFraction = _ETHDrawn.mul(_price).div(totalLUSDSupply);\n\n        uint newBaseRate = decayedBaseRate.add(redeemedLUSDFraction.div(BETA));\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate < 1e18 ? newBaseRate : 1e18;  // cap baseRate at a maximum of 100%\n        assert(baseRate <= 1e18 && baseRate > 0); // Base rate is always non-zero after redemption\n\n        _updateLastFeeOpTime();\n\n        return baseRate;\n    }\n\n    function _getRedemptionFee(uint _ETHDrawn) internal view returns (uint) {\n       return baseRate.mul(_ETHDrawn).div(1e18);\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) {\n        return _LUSDDebt.mul(baseRate).div(1e18);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate <= 1e18);  // The baseRate can decay to 0\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(1e18);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(msg.sender == borrowerOperationsAddress, \"TroveManager: Caller is not the BorrowerOperations contract\");\n    }\n\n    function _requireTroveisActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, \"TroveManager: Trove does not exist or is closed\");\n    }\n\n    function _requireLUSDBalanceCoversRedemption(address _redeemer, uint _amount) internal view {\n        require(lusdToken.balanceOf(_redeemer) >= _amount, \"TroveManager: Requested redemption amount must be <= user's LUSD token balance\");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \"TroveManager: Only one trove in the system\");\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    },
    "contracts/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/* \n* A sorted doubly linked list with nodes sorted in descending order.\n* \n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner. \n* Nodes are ordered according to their current individual collateral ratio (ICR).\n* \n* The list optionally accepts insert position hints.\n* \n* ICRs are computed dynamically at runtime, and not stored on the Node. This is because ICRs of active Troves \n* change dynamically as liquidation events occur.\n* \n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the ICRs of all active Troves, \n* but maintains their order. A node inserted based on current ICR will maintain the correct position, \n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n* Thus, Nodes remain sorted by current ICR.\n* \n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt \n* to their position.\n*\n* The list is a modification of the following audited SortedDoublyLinkedList:\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n* \n*\n* Changes made in the Liquity implementation:\n*\n* - Keys have been removed from nodes\n*\n* - Ordering checks for insertion are performed by comparing an ICR argument to the current ICR, calculated at runtime. \n*   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\n*\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n*/\ncontract SortedTroves is Ownable, ISortedTroves {\n    using SafeMath for uint256;\n\n    event TroveManagerAddressChanged(address _newTrovelManagerAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n    address public TroveManagerAddress;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId;                  // Id of next node (smaller ICR) in the list\n        address prevId;                  // Id of previous node (larger ICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head;                        // Head of the list. Also the node in the list with the largest ICR\n        address tail;                        // Tail of the list. Also the node in the list with the smallest ICR\n        uint256 maxSize;                     // Maximum size of the list\n        uint256 size;                        // Current size of the list\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Dependency setters --- \n\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\n        require(_size > 0, \"SortedTroves: Size can’t be zero\");\n\n        data.maxSize = _size;\n\n        TroveManagerAddress = _TroveManagerAddress;\n        troveManager = ITroveManager(_TroveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_TroveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        _renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert (address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) external override {\n        _requireCallerIsBOorTroveM();\n        _insert (_id, _ICR, _price, _prevId, _nextId);\n    }\n    \n    function _insert(address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // ICR must be non-zero\n        require(_ICR > 0, \"SortedTroves: ICR must be positive\");\n\n        address prevId = _prevId; \n        address nextId = _nextId; \n\n        if (!validInsertPosition(_ICR, _price, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = findInsertPosition(_ICR, _price, prevId, nextId);   \n        }\n        \n         data.nodes[_id].exists = true;  \n    \n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id; \n            data.tail = _id; \n        } else if (prevId == address(0)) { \n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head; \n            data.nodes[data.head].prevId = _id;  \n            data.head = _id; \n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else { \n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId; \n            data.nodes[_id].prevId = prevId; \n            data.nodes[prevId].nextId = _id; \n            data.nodes[nextId].prevId = _id; \n        }\n\n        data.size = data.size.add(1); \n    }\n\n    function remove(address _id) external override {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) { \n            // List contains more than a single node\n            if (_id == data.head) { \n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId; \n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0); \n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id]; \n        data.size = data.size.sub(1); \n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new ICR\n     * @param _id Node's id\n     * @param _newICR Node's new ICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(address _id, uint256 _newICR, uint _price, address _prevId, address _nextId) external override {\n        _requireCallerIsBOorTroveM();\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // ICR must be non-zero\n        require(_newICR > 0, \"SortedTroves: ICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        // Insert node\n        _insert(_id, _newICR, _price, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view override returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view override returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view override returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view override returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest ICR)\n     */\n    function getFirst() external view override returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest ICR)\n     */\n    function getLast() external view override returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller ICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view override returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger ICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view override returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given ICR\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) public view override returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return data.head == _nextId && _ICR >= troveManager.getCurrentICR(_nextId, _price);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return data.tail == _prevId && _ICR <= troveManager.getCurrentICR(_prevId, _price);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_ICR` falls between the two nodes' ICRs\n            return data.nodes[_prevId].nextId == _nextId && \n                   troveManager.getCurrentICR(_prevId, _price) >= _ICR && \n                   _ICR >= troveManager.getCurrentICR(_nextId, _price);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger ICRs to smaller ICRs) to find a valid insert position\n     * @param _ICR Node's ICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(uint256 _ICR, uint _price, address _startId) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (data.head == _startId && _ICR >= troveManager.getCurrentICR(_startId, _price)) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (prevId != address(0) && !validInsertPosition(_ICR, _price, prevId, nextId)) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller ICRs to larger ICRs) to find a valid insert position\n     * @param _ICR Node's ICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(uint256 _ICR, uint _price, address _startId) internal view returns (address, address) {       \n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (data.tail == _startId && _ICR <= troveManager.getCurrentICR(_startId, _price)) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (nextId != address(0) && !validInsertPosition(_ICR, _price, prevId, nextId)) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given ICR\n     * @param _ICR Node's ICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(uint256 _ICR, uint _price, address _prevId, address _nextId) public view override returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (!contains(prevId) || _ICR > troveManager.getCurrentICR(prevId, _price)) {\n                // `prevId` does not exist anymore or now has a smaller ICR than the given ICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (!contains(nextId) || _ICR < troveManager.getCurrentICR(nextId, _price)) {\n                // `nextId` does not exist anymore or now has a larger ICR than the given ICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_ICR, _price, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_ICR, _price, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_ICR, _price, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_ICR, _price, prevId);\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == TroveManagerAddress, \"SortedTroves: Caller is not the TroveManager\");\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(msg.sender == borrowerOperationsAddress || msg.sender == TroveManagerAddress,\n                \"SortedTroves: Caller is neither BO nor TroveM\");\n    }\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IPriceFeed.sol\";\nimport \"./Dependencies/AggregatorV3Interface.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/*\n* PriceFeed for mainnet deployment, to be connected to Chainlink's live ETH:USD aggregator reference contract.\n*/\ncontract PriceFeed is Ownable, IPriceFeed {\n    using SafeMath for uint256;\n\n    // Mainnet Chainlink aggregator\n    AggregatorV3Interface public priceAggregator;\n\n    // Use to convert to 18-digit precision uints\n    uint constant public TARGET_DIGITS = 18;  \n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _priceAggregatorAddress\n    )\n        external\n        onlyOwner\n    {\n        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);\n        _renounceOwnership();\n    }\n\n    /**\n     * Returns the latest price obtained from the Chainlink ETH:USD aggregator reference contract.\n     * https://docs.chain.link/docs/get-the-latest-price\n     */\n    function getPrice() public view override returns (uint) {\n        (, int priceAnswer,, uint timeStamp,) = priceAggregator.latestRoundData();\n    \n        require(timeStamp > 0 && timeStamp <= block.timestamp, \"PriceFeed: price timestamp from aggregator is 0, or in future\");\n        require(priceAnswer >= 0, \"PriceFeed: price answer from aggregator is negative\");\n        \n        uint8 answerDigits = priceAggregator.decimals();\n        uint price = uint256(priceAnswer);\n        \n        // currently the Aggregator returns an 8-digit precision, but we handle the case of future changes\n        if (answerDigits > TARGET_DIGITS) { \n            price = price.div(10 ** (answerDigits - TARGET_DIGITS));\n        }\n        else if (answerDigits < TARGET_DIGITS) {\n            price = price.mul(10 ** (TARGET_DIGITS - answerDigits));\n        } \n        return price;\n    }\n}\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/IStabilityPool.sol';\nimport './Interfaces/IPool.sol';\nimport './Interfaces/IBorrowerOperations.sol';\nimport './Interfaces/ITroveManager.sol';\nimport './Interfaces/ILUSDToken.sol';\nimport './Interfaces/ISortedTroves.sol';\nimport './Interfaces/IPriceFeed.sol';\nimport \"./Interfaces/ICommunityIssuance.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/LiquitySafeMath128.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/* \n * The Stability Pool holds LUSD tokens deposited by Stability Pool depositors. \n * \n * When a trove is liquidated, then depending on system conditions, some of its LUSD debt gets offset with\n * LUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of LUSD tokens in the Stability Pool is burned.\n * \n * Thus, a liquidation causes each depositor to receive a LUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an ETH gain, as the ETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total LUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and ETH gains that has O(1) complexity.\n * \n * When a liquidation occurs, rather than updating each depositor's deposit and ETH gain, we simply update two state variables: \n * a product P, and a sum S. \n * \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits \n * and accumulated ETH gains over time, as liquidations occur, using just these two variables P and S. When depositors join the \n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated ETH gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool, \n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated ETH gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding ETH gain \n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n * \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated ETH gain is paid out, their new deposit is recorded \n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S. \n * Essentially, they make a fresh deposit that overwrites the old one.\n * \n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[. \n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P \n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n * \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-18 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e18, and increment a currentScale factor by 1.\n *\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0 \n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  \n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer, \n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0. \n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e18). If it spans more than one scale change, we define the compounded deposit \n * as 0, since it is now less than 1e-18'th of its initial value (e.g. a deposit of 1 billion LUSD has depleted to 1 billionth of an LUSD).\n *\n *\n *  --- TRACKING DEPOSITOR'S ETH GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated ETH gain, during the epoch in which the deposit was non-zero and earned ETH.\n *\n * We calculate the depositor's accumulated ETH gain for the scale at which they made the deposit, using the ETH gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e18:\n * e_2 = d_t * (S - S_t) / (P_t * 1e18)\n * \n * The sum of (e_1 + e_2) captures the depositor's total accumulated ETH gain, handling the case where their \n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n * \n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS --- \n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n * \n *\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS --- \n *\n * An LQTY issuance event occurs at every deposit operation, and every liquidation. \n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n * \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-depositors\n *\n * We use the same mathematical product-sum approach to track LQTY gains for depositors, where 'G' is the sum corresponding to LQTY gains. \n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is LiquityBase, Ownable, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    ILUSDToken public lusdToken;\n\n    IPool public activePool;\n    address public activePoolAddress;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n    IPriceFeed public priceFeed;\n\n    ICommunityIssuance public communityIssuance;\n    address public communityIssuanceAddress;\n\n    uint256 internal ETH;  // deposited ether tracker\n\n    // Tracker for LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalLUSDDeposits;\n\n   // --- Data structures ---\n\n    struct FrontEnd {\n        uint kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        uint S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping (address => Deposit) public deposits;  // depositor address -> Deposit struct\n    mapping (address => Snapshots) public depositSnapshots;  // depositor address -> snapshots struct\n\n    mapping (address => FrontEnd) public frontEnds;  // front end address -> FrontEnd struct\n    mapping (address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n    mapping (address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n    * after a series of liquidations have occurred, each of which cancel some LUSD debt with the deposit.\n    * \n    * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  \n    */\n    uint public P = 1e18;\n\n    // Each time the scale of P shifts by 1e18, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* ETH Gain sum 'S': During its lifetime, each deposit d_t earns an ETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n    * is the depositor's snapshot of S taken at the time t when the deposit was made.\n    * \n    * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n    * \n    * - The inner mapping records the sum S at different scales\n    * - The outer mapping records the (scale => sum) mappings, for different epochs. \n    */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToSum;\n\n    /*\n    * Similarly, the sum 'G' is used to calculate LQTY gains. During it's lifetime, each deposit d_t earns a LQTY gain of\n    *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n    *\n    *  LQTY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n    *  In each case, the LQTY reward is issued (i.e. G is updated), before other state changes are made. \n    */\n    mapping (uint => mapping(uint => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the LQTY issuance calculation\n    uint public lastLQTYError;\n    // Error trackers for the error correction in the offset calculation\n    uint public lastETHError_Offset;\n    uint public lastLUSDLossError_Offset;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IPool(_activePoolAddress);\n        activePoolAddress = _activePoolAddress;\n        lusdToken = ILUSDToken(_lusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuanceAddress = _communityIssuanceAddress;\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getETH() external view override returns (uint) {\n        return ETH;\n    }\n\n    function getTotalLUSDDeposits() external view override returns (uint) {\n        return totalLUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Tags the deposit with the provided front end tag param, if it's a new deposit\n    * - Sends depositor's accumulated gains (LQTY, ETH) to depositor \n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n    */\n    function provideToSP(uint _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        _triggerLQTYIssuance();\n\n        if (initialDeposit == 0) {_setFrontEndTag(msg.sender, _frontEndTag);}\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedLUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        _sendETHGainToDepositor(depositorETHGain);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss); // LUSD Loss required for event log\n    }\n\n    /*  withdrawFromSP():\n    *\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Removes the deposit's front end tag if it is a full withdrawal\n    * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\n    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n    * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n    *\n    * If _amount > userDeposit, the user withdraws all of their compounded deposit. \n    */\n    function withdrawFromSP(uint _amount) external override {\n        _requireNoUnderCollateralizedTroves();\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        _triggerLQTYIssuance();\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDtoWithdraw = LiquityMath._min(_amount, compoundedLUSDDeposit);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.sub(LUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendLUSDToDepositor(msg.sender, LUSDtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedLUSDDeposit.sub(LUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        _sendETHGainToDepositor(depositorETHGain);\n\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);  // LUSD Loss required for event log\n    }\n\n    /* withdrawETHGainToTrove:\n    * - Triggers a LQTY issuance, based on time passed since the last. The LQTY issuance is shared between *all* depositors and front ends\n    * - Sends all depositor's LQTY gain to  depositor\n    * - Sends all tagged front end's LQTY gain to the tagged front end \n    * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n    * - Leaves their compounded deposit in the Stability Pool\n    * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawETHGainToTrove(address _hint) external override {\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasETHGain(msg.sender);\n\n        _triggerLQTYIssuance();\n\n        uint depositorETHGain = getDepositorETHGain(msg.sender);\n\n        uint compoundedLUSDDeposit = getCompoundedLUSDDeposit(msg.sender);\n        uint LUSDLoss = initialDeposit.sub(compoundedLUSDDeposit); // Needed only for event log\n\n        // First pay out any LQTY gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutLQTYGains(msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _updateDepositAndSnapshots(msg.sender, compoundedLUSDDeposit);\n\n        /* Emit events before transferring ETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the ETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit ETHGainWithdrawn(msg.sender, depositorETHGain, LUSDLoss);\n        emit UserDepositChanged(msg.sender, compoundedLUSDDeposit);\n\n        ETH = ETH.sub(depositorETHGain);\n        emit ETHBalanceUpdated(ETH);\n        emit EtherSent(msg.sender, depositorETHGain);\n\n        borrowerOperations.moveETHGainToTrove{ value: depositorETHGain }(msg.sender, _hint);\n    }\n\n    // --- LQTY issuance functions ---\n\n    function _triggerLQTYIssuance() internal {\n        uint LQTYIssuance = communityIssuance.issueLQTY();\n       _updateG(LQTYIssuance);\n    }\n\n    function _updateG(uint _LQTYIssuance) internal {\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n\n        /* \n        * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later \n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract. \n        */\n        if (totalLUSD == 0) {return;}\n\n        uint LQTYPerUnitStaked;\n        LQTYPerUnitStaked =_computeLQTYPerUnitStaked(_LQTYIssuance, totalLUSD);\n\n        uint marginalLQTYGain = LQTYPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale].add(marginalLQTYGain);\n    }\n\n    function _computeLQTYPerUnitStaked(uint _LQTYIssuance, uint _totalLUSDDeposits) internal returns (uint) {\n        uint LQTYNumerator = _LQTYIssuance.mul(1e18).add(lastLQTYError);\n\n        uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);\n        lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return LQTYPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /* \n    * Cancel out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n    * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n    * Only called by liquidation functions in the TroveManager. \n    */\n    function offset(uint _debtToOffset, uint _collToAdd) external override {\n        _requireCallerIsTroveManager();\n        uint totalLUSD = totalLUSDDeposits; // cached to save an SLOAD\n        if (totalLUSD == 0 || _debtToOffset == 0) { return; }\n\n        _triggerLQTYIssuance();\n\n        (uint ETHGainPerUnitStaked,\n            uint LUSDLossPerUnitStaked) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalLUSD);\n\n        _updateRewardSumAndProduct(ETHGainPerUnitStaked, LUSDLossPerUnitStaked);  // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalLUSDDeposits\n    )\n        internal\n        returns (uint ETHGainPerUnitStaked, uint LUSDLossPerUnitStaked)\n    {\n        uint LUSDLossNumerator = _debtToOffset.mul(1e18).sub(lastLUSDLossError_Offset);\n        uint ETHNumerator = _collToAdd.mul(1e18).add(lastETHError_Offset);\n\n        /*\n        * Compute the LUSD and ETH rewards. Uses a \"feedback\" error correction, to keep\n        * the cumulative error in the P and S state variables low.\n        */\n        if (_debtToOffset >= _totalLUSDDeposits) {\n            LUSDLossPerUnitStaked = 1e18;\n            lastLUSDLossError_Offset = 0;\n        } else {\n            /* \n            * Add 1 to make error in quotient positive. We want \"slightly too much\" LUSD loss,\n            * which ensures the error in any given compoundedLUSDDeposit favors the Stability Pool. \n            */\n            LUSDLossPerUnitStaked = (LUSDLossNumerator.div(_totalLUSDDeposits)).add(1); \n            lastLUSDLossError_Offset = (LUSDLossPerUnitStaked.mul(_totalLUSDDeposits)).sub(LUSDLossNumerator);\n        }\n\n        ETHGainPerUnitStaked = ETHNumerator.div(_totalLUSDDeposits);\n        lastETHError_Offset = ETHNumerator.sub(ETHGainPerUnitStaked.mul(_totalLUSDDeposits));\n\n        return (ETHGainPerUnitStaked, LUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(uint _ETHGainPerUnitStaked, uint _LUSDLossPerUnitStaked) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_LUSDLossPerUnitStaked <= 1e18);\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool LUSD in the liquidation. \n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - LUSDLossPerUnitStaked)\n        */\n        uint newProductFactor = _LUSDLossPerUnitStaked >= 1e18 ? 0 : uint(1e18).sub(_LUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\n        /*  \n        * Calculate the new S first, before we update P.\n        * The ETH gain for any given depositor from a liquidation depends on the value of their deposit \n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n        *\n        * Since S corresponds to ETH gain, and P to deposit loss, we update S first.\n        */\n        uint marginalETHGain = _ETHGainPerUnitStaked.mul(currentP);\n        uint newS = currentS.add(marginalETHGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            currentScale = 0;\n            newP = 1e18;\n\n        // If multiplying P by a non-zero product factor would round P to zero, increment the scale\n        } else if (currentP.mul(newProductFactor) < 1e18) {\n            newP = currentP.mul(newProductFactor);\n            currentScale = currentScaleCached.add(1);\n        } else {\n            newP = currentP.mul(newProductFactor).div(1e18);\n        }\n\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\n        // Cancel the liquidated LUSD debt with the LUSD in the stability pool\n        activePool.decreaseLUSDDebt(_debtToOffset);\n        _decreaseLUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        lusdToken.burn(address(this), _debtToOffset);\n\n        activePool.sendETH(address(this), _collToAdd); \n    }\n\n    function _decreaseLUSD(uint _amount) internal {\n        uint newTotalLUSDDeposits = totalLUSDDeposits.sub(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit LUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the ETH gain earned by the deposit since its last snapshots were taken. \n    * Given by the formula:  E = d0 * (S - S(0))/P(0)\n    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively. \n    * d0 is the last recorded deposit value. \n    */\n    function getDepositorETHGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint ETHGain = _getETHGainFromSnapshots(initialDeposit, snapshots);\n        return ETHGain;\n    }\n\n    function _getETHGainFromSnapshots(uint initialDeposit, Snapshots memory snapshots) internal view returns (uint) {\n        /*  \n        * Grab the sum 'S' from the epoch at which the stake was made. The ETH gain may span up to one scale change.\n        * If it does, the second portion of the ETH gain is scaled by 1e18.\n        * If the gain spans no scale change, the second portion will be 0. \n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint S_Snapshot = snapshots.S;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(S_Snapshot);\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(1e18);\n\n        uint ETHGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(1e18);\n\n        return ETHGain;\n    }\n\n    /*\n    * Calculate the LQTY gain earned by a deposit since its last snapshots were taken. \n    * Given by the formula:  LQTY = d0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    * d0 is the last recorded deposit value. \n    */\n    function getDepositorLQTYGain(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {return 0;}\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /* \n        * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n        * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n        * which they made their deposit.\n        */\n        uint kickbackRate = frontEndTag == address(0) ? 1e18 : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint LQTYGain = kickbackRate.mul(_getLQTYGainFromSnapshots(initialDeposit, snapshots)).div(1e18);\n\n        return LQTYGain;\n    }\n\n    /*\n    * Return the LQTY gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n    *\n    * D0 is the last recorded value of the front end's total tagged deposits. \n    */\n    function getFrontEndLQTYGain(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint frontEndShare = uint(1e18).sub(kickbackRate);\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint LQTYGain = frontEndShare.mul(_getLQTYGainFromSnapshots(frontEndStake, snapshots)).div(1e18);\n        return LQTYGain;\n    }\n\n    function _getLQTYGainFromSnapshots(uint initialStake, Snapshots memory snapshots) internal view returns (uint) {\n       /*  \n        * Grab the sum 'G' from the epoch at which the stake was made. The LQTY gain may span up to one scale change.\n        * If it does, the second portion of the LQTY gain is scaled by 1e18.\n        * If the gain spans no scale change, the second portion will be 0. \n        */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint G_Snapshot = snapshots.G;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(1e18);\n\n        uint LQTYGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(1e18);\n\n        return LQTYGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /* \n    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n    */\n    function getCompoundedLUSDDeposit(address _depositor) public view override returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) { return 0; }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /* \n    * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n    * where P(0) is the depositor's snapshot of the product P, taken at the last time\n    * when one of the front end's tagged deposits updated their deposit.\n    *\n    * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n    */\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) { return 0; }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) { return 0; }\n\n        uint compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n        * at least 1e-18 -- so return 0.\n        */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(1e18);\n        } else {\n            compoundedStake = 0;\n        }\n\n        /*\n        * If compounded deposit is less than a billionth of the initial deposit, return 0.  \n        *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error \n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n        * than it's theoretical value.\n        *\n        * Thus it's unclear whether this line is still really needed.\n        */\n        if (compoundedStake < initialStake.div(1e9)) {return 0;}\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for LUSD deposit, ETH gains and LQTY gains ---\n\n    // Transfer the LUSD tokens from the user to the Stability Pool's address, and update its recorded LUSD\n    function _sendLUSDtoStabilityPool(address _address, uint _amount) internal {\n        lusdToken.sendToPool(_address, address(this), _amount);\n        uint newTotalLUSDDeposits = totalLUSDDeposits.add(_amount);\n        totalLUSDDeposits = newTotalLUSDDeposits;\n        emit LUSDBalanceUpdated(newTotalLUSDDeposits);\n    }\n\n    function _sendETHGainToDepositor(uint _amount) internal {\n        if (_amount == 0) {return;}\n        uint newETH = ETH.sub(_amount);\n        ETH = newETH;\n        emit ETHBalanceUpdated(newETH);\n        emit EtherSent(msg.sender, _amount);\n\n        (bool success, ) = msg.sender.call{ value: _amount }(\"\");\n        require(success, \"StabilityPool: sending ETH failed\");\n    }\n\n    // Send LUSD to user and decrease LUSD in Pool\n    function _sendLUSDToDepositor(address _depositor, uint LUSDWithdrawal) internal {\n        lusdToken.returnFromPool(address(this), _depositor, LUSDWithdrawal);\n        _decreaseLUSD(LUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n    }\n\n\n    function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutLQTYGains(address _depositor, address _frontEnd) internal {\n        // Pay out front end's LQTY gain\n        if (_frontEnd != address(0)) {\n            uint frontEndLQTYGain = getFrontEndLQTYGain(_frontEnd);\n            communityIssuance.sendLQTY(_frontEnd, frontEndLQTYGain);\n            emit LQTYPaidToFrontEnd(_frontEnd, frontEndLQTYGain);\n        }\n\n        // Pay out depositor's LQTY gain\n        uint depositorLQTYGain = getDepositorLQTYGain(_depositor);\n        communityIssuance.sendLQTY(_depositor, depositorLQTYGain);\n\n        emit LQTYPaidToDepositor(_depositor, depositorLQTYGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require( msg.sender == activePoolAddress, \"StabilityPool: Caller is not ActivePool\");\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(msg.sender == address(troveManager), \"StabilityPool: Caller is not TroveManager\");\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        uint price = priceFeed.getPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(ICR >= MCR, \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\");\n    }\n\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n        require(_initialDeposit > 0, 'StabilityPool: User must have a non-zero deposit');\n    }\n\n     function _requireUserHasNoDeposit(address _address) internal view {\n        uint initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, 'StabilityPool: User must have no deposit');\n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, 'StabilityPool: Amount must be non-zero');\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(troveManager.getTroveStatus(_depositor) == 1, \"StabilityPool: caller must have an active trove to withdraw ETHGain to\");\n    }\n\n    function _requireUserHasETHGain(address _depositor) internal view {\n        uint ETHGain = getDepositorETHGain(_depositor);\n        require(ETHGain > 0, \"StabilityPool: caller must have non-zero ETH Gain\");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(frontEnds[_address].registered == false, \"StabilityPool: must not already be a registered front end\");\n    }\n\n     function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(frontEnds[_address].registered || _address == address(0),\n            \"StabilityPool: Tag must be a registered front end, or the zero address\");\n    }\n\n    function  _requireValidKickbackRate(uint _kickbackRate) internal pure {\n        require (_kickbackRate <= 1e18, \"StabilityPool: Kickback rate must be in range [0,1]\");\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/TestContracts/ActivePoolTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../ActivePool.sol\";\n\ncontract ActivePoolTester is ActivePool {\n    \n    function unprotectedIncreaseLUSDDebt(uint _amount) external {\n        LUSDDebt  = LUSDDebt.add(_amount);\n    }\n\n    function unprotectedPayable() external payable {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/TestContracts/BorrowerOperationsTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../BorrowerOperations.sol\";\n\n/* Tester contract inherits from BorrowerOperations, and provides external functions \nfor testing the parent's internal functions. */\ncontract BorrowerOperationsTester is BorrowerOperations {\n\n    function getNewICRFromTroveChange\n    (\n        uint _coll, \n        uint _debt, \n        uint _collChange, \n        bool isCollIncrease, \n        uint _debtChange, \n        bool isDebtIncrease, \n        uint _price\n    ) \n    external\n    pure\n    returns (uint)\n    {\n        return _getNewICRFromTroveChange(_coll, _debt, _collChange, isCollIncrease, _debtChange, isDebtIncrease, _price);\n    }\n\n    function getNewTCRFromTroveChange\n    (\n        uint _collChange, \n        bool isCollIncrease,  \n        uint _debtChange, \n        bool isDebtIncrease, \n        uint _price\n    ) \n    external \n    view\n    returns (uint) \n    {\n        return _getNewTCRFromTroveChange(_collChange, isCollIncrease, _debtChange, isDebtIncrease, _price);\n    }\n\n    function getUSDValue(uint _coll, uint _price) external pure returns (uint) {\n        return _getUSDValue(_coll, _price);\n    }\n\n    function callInternalAdjustLoan\n    (\n        address _borrower, \n        uint _collWithdrawal, \n        uint _debtChange, \n        bool _isDebtIncrease, \n        address _hint) \n        external \n    {\n        _adjustTrove(_borrower, _collWithdrawal, _debtChange, _isDebtIncrease, _hint);\n    }\n\n\n    // Payable fallback function\n    receive() external payable { }\n}\n"
    },
    "contracts/TestContracts/CDPManagerTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../TroveManager.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n\n    function computeICR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\n        return LiquityMath._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(uint _coll) external pure returns (uint) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getLUSDGasCompensation() external pure returns (uint) {\n        return LUSD_GAS_COMPENSATION;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function unprotectedDecayBaseRateFromBorrowing() external returns (uint) {\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate >= 0 && baseRate <= 1e18);\n        \n        _updateLastFeeOpTime();\n        return baseRate;\n    }\n\n    function minutesPassedSinceLastFeeOp() external view returns (uint) {\n        return _minutesPassedSinceLastFeeOp();\n    }\n\n    function setLastFeeOpTimeToNow() external {\n        lastFeeOperationTime = block.timestamp;\n    }\n\n    function setBaseRate(uint _baseRate) external {\n        baseRate = _baseRate;\n    }\n\n    function callGetRedemptionFee(uint _ETHDrawn) external view returns (uint) {\n        _getRedemptionFee(_ETHDrawn);\n    }  \n\n    function getActualDebtFromComposite(uint _debtVal) external pure returns (uint) {\n        return _getNetDebt(_debtVal);\n    }\n\n    function callInternalRemoveTroveOwner(address _troveOwner) external {\n        uint troveOwnersArrayLength = TroveOwners.length;\n        _removeTroveOwner(_troveOwner, troveOwnersArrayLength);\n    }\n}\n"
    },
    "contracts/TestContracts/CommunityIssuanceTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../LQTY/CommunityIssuance.sol\";\n\ncontract CommunityIssuanceTester is CommunityIssuance {\n    function obtainLQTY(uint _amount) external {\n        lqtyToken.transfer(msg.sender, _amount);\n    }\n\n    function setDeploymentTime() external {\n        deploymentTime = block.timestamp;\n    }\n\n    function getCumulativeIssuanceFraction() external view returns (uint) {\n       return _getCumulativeIssuanceFraction();\n    }\n\n    function unprotectedIssueLQTY() external returns (uint) {\n        // No checks on caller address\n       \n        uint latestTotalLQTYIssued = LQTYSupplyCap.mul(_getCumulativeIssuanceFraction()).div(1e18);\n        uint issuance = latestTotalLQTYIssued.sub(totalLQTYIssued);\n      \n        totalLQTYIssued = latestTotalLQTYIssued;\n        return issuance;\n    }\n}\n"
    },
    "contracts/TestContracts/DefaultPoolTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../DefaultPool.sol\";\n\ncontract DefaultPoolTester is DefaultPool {\n    \n    function unprotectedIncreaseLUSDDebt(uint _amount) external {\n        LUSDDebt  = LUSDDebt.add(_amount);\n    }\n\n    function unprotectedPayable() external payable {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/TestContracts/Destructible.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ncontract Destructible {\n    \n    receive() external payable {}\n    \n    function destruct(address payable _receiver) external {\n        selfdestruct(_receiver);\n    }\n}\n"
    },
    "contracts/TestContracts/EchidnaProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../TroveManager.sol\";\nimport \"../BorrowerOperations.sol\";\nimport \"../StabilityPool.sol\";\nimport \"../LUSDToken.sol\";\n\ncontract EchidnaProxy {\n    TroveManager troveManager;\n    BorrowerOperations borrowerOperations;\n    StabilityPool stabilityPool;\n    LUSDToken lusdToken;\n\n    constructor(\n        TroveManager _troveManager,\n        BorrowerOperations _borrowerOperations,\n        StabilityPool _stabilityPool,\n        LUSDToken _lusdToken\n    ) public {\n        troveManager = _troveManager;\n        borrowerOperations = _borrowerOperations;\n        stabilityPool = _stabilityPool;\n        lusdToken = _lusdToken;\n    }\n\n    receive() external payable {\n        // do nothing\n    }\n\n    // TroveManager\n\n    function liquidatePrx(address _user) external {\n        troveManager.liquidate(_user);\n    }\n\n    function liquidateTrovesPrx(uint _n) external {\n        troveManager.liquidateTroves(_n);\n    }\n\n    function batchLiquidateTrovesPrx(address[] calldata _troveArray) external {\n        troveManager.batchLiquidateTroves(_troveArray);\n    }\n\n    function redeemCollateralPrx(\n        uint _LUSDAmount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    ) external {\n        troveManager.redeemCollateral(_LUSDAmount, _firstRedemptionHint, _partialRedemptionHint, _partialRedemptionHintICR, _maxIterations);\n    }\n\n    // Borrower Operations\n    function openTrovePrx(uint _ETH, uint _LUSDAmount, address _hint) external payable {\n        borrowerOperations.openTrove{value: _ETH}(_LUSDAmount, _hint);\n    }\n\n    function addCollPrx(uint _ETH, address _hint) external payable {\n        borrowerOperations.addColl{value: _ETH}(_hint);\n    }\n\n    function withdrawCollPrx(uint _amount, address _hint) external {\n        borrowerOperations.withdrawColl(_amount, _hint);\n    }\n\n    function withdrawLUSDPrx(uint _amount, address _hint) external {\n        borrowerOperations.withdrawLUSD(_amount, _hint);\n    }\n\n    function repayLUSDPrx(uint _amount, address _hint) external {\n        borrowerOperations.repayLUSD(_amount, _hint);\n    }\n\n    function closeTrovePrx() external {\n        borrowerOperations.closeTrove();\n    }\n\n    function adjustTrovePrx(uint _ETH, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _hint) external payable {\n        borrowerOperations.adjustTrove{value: _ETH}(_collWithdrawal, _debtChange, _isDebtIncrease, _hint);\n    }\n\n    // Pool Manager\n    function provideToSPPrx(uint _amount, address _frontEndTag) external {\n        stabilityPool.provideToSP(_amount, _frontEndTag);\n    }\n\n    function withdrawFromSPPrx(uint _amount) external {\n        stabilityPool.withdrawFromSP(_amount);\n    }\n\n    // LUSD Token\n\n    function transferPrx(address recipient, uint256 amount) external returns (bool) {\n        return lusdToken.transfer(recipient, amount);\n    }\n\n    function approvePrx(address spender, uint256 amount) external returns (bool) {\n        return lusdToken.approve(spender, amount);\n    }\n\n    function transferFromPrx(address sender, address recipient, uint256 amount) external returns (bool) {\n        return lusdToken.transferFrom(sender, recipient, amount);\n    }\n\n    function increaseAllowancePrx(address spender, uint256 addedValue) external returns (bool) {\n        return lusdToken.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowancePrx(address spender, uint256 subtractedValue) external returns (bool) {\n        return lusdToken.decreaseAllowance(spender, subtractedValue);\n    }\n}\n"
    },
    "contracts/TestContracts/EchidnaTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.11;\n\nimport \"../TroveManager.sol\";\nimport \"../BorrowerOperations.sol\";\nimport \"../ActivePool.sol\";\nimport \"../DefaultPool.sol\";\nimport \"../StabilityPool.sol\";\nimport \"../CollSurplusPool.sol\";\nimport \"../LUSDToken.sol\";\nimport \"./PriceFeedTestnet.sol\";\nimport \"../SortedTroves.sol\";\nimport \"./EchidnaProxy.sol\";\n//import \"../Dependencies/console.sol\";\n\n// Run with:\n// rm -f fuzzTests/corpus/* # (optional)\n// ~/.local/bin/echidna-test contracts/TestContracts/EchidnaTester.sol --contract EchidnaTester --config fuzzTests/echidna_config.yaml\n\ncontract EchidnaTester {\n    using SafeMath for uint;\n\n    uint constant private NUMBER_OF_ACTORS = 100;\n    uint constant private INITIAL_BALANCE = 1e24;\n    uint private MCR;\n    uint private CCR;\n    uint private LUSD_GAS_COMPENSATION;\n    address public GAS_POOL_ADDRESS;\n\n    TroveManager public troveManager;\n    BorrowerOperations public borrowerOperations;\n    ActivePool public activePool;\n    DefaultPool public defaultPool;\n    StabilityPool public stabilityPool;\n    CollSurplusPool public collSurplusPool;\n    LUSDToken public lusdToken;\n    PriceFeedTestnet priceFeedTestnet;\n    SortedTroves sortedTroves;\n\n    EchidnaProxy[NUMBER_OF_ACTORS] public echidnaProxies;\n\n    uint private numberOfTroves;\n\n    constructor() public payable {\n        troveManager = new TroveManager();\n        borrowerOperations = new BorrowerOperations();\n        activePool = new ActivePool();\n        defaultPool = new DefaultPool();\n        stabilityPool = new StabilityPool();\n        lusdToken = new LUSDToken(\n            address(troveManager),\n            address(stabilityPool),\n            address(borrowerOperations)\n        );\n\n        collSurplusPool = new CollSurplusPool();\n        priceFeedTestnet = new PriceFeedTestnet();\n\n        sortedTroves = new SortedTroves();\n\n        troveManager.setAddresses(address(borrowerOperations), \n            address(activePool), address(defaultPool), \n            address(stabilityPool), address(collSurplusPool), \n            address(priceFeedTestnet), address(lusdToken), \n            address(sortedTroves), address(0));\n       \n        borrowerOperations.setAddresses(address(troveManager), \n            address(activePool), address(defaultPool), \n            address(stabilityPool), address(collSurplusPool), \n            address(priceFeedTestnet), address(sortedTroves), \n            address(lusdToken), address(0));\n\n        activePool.setAddresses(address(borrowerOperations), \n            address(troveManager), address(stabilityPool), address(defaultPool));\n\n        defaultPool.setAddresses(address(troveManager), address(activePool));\n        \n        stabilityPool.setAddresses(address(borrowerOperations), \n            address(troveManager), address(activePool), address(lusdToken), \n            address(sortedTroves), address(priceFeedTestnet), address(0));\n\n        collSurplusPool.setAddresses(address(borrowerOperations), \n             address(troveManager), address(activePool));\n    \n        sortedTroves.setParams(1e18, address(troveManager), address(borrowerOperations));\n\n        for (uint i = 0; i < NUMBER_OF_ACTORS; i++) {\n            echidnaProxies[i] = new EchidnaProxy(troveManager, borrowerOperations, stabilityPool, lusdToken);\n            (bool success, ) = address(echidnaProxies[i]).call{value: INITIAL_BALANCE}(\"\");\n            require(success);\n        }\n\n        MCR = borrowerOperations.MCR();\n        CCR = borrowerOperations.CCR();\n        LUSD_GAS_COMPENSATION = borrowerOperations.LUSD_GAS_COMPENSATION();\n        require(MCR > 0);\n        require(CCR > 0);\n\n        GAS_POOL_ADDRESS = troveManager.GAS_POOL_ADDRESS();\n\n        // TODO:\n        priceFeedTestnet.setPrice(1e22);\n    }\n\n    // TroveManager\n\n    function liquidateExt(uint _i, address _user) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].liquidatePrx(_user);\n    }\n\n    function liquidateTrovesExt(uint _i, uint _n) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].liquidateTrovesPrx(_n);\n    }\n\n    function batchLiquidateTrovesExt(uint _i, address[] calldata _troveArray) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].batchLiquidateTrovesPrx(_troveArray);\n    }\n\n    function redeemCollateralExt(\n        uint _i,\n        uint _LUSDAmount,\n        address _firstRedemptionHint,\n        address _partialRedemptionHint,\n        uint _partialRedemptionHintICR\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].redeemCollateralPrx(_LUSDAmount, _firstRedemptionHint, _partialRedemptionHint, _partialRedemptionHintICR, 0);\n    }\n\n    // Borrower Operations\n\n    function getAdjustedETH(uint actorBalance, uint _ETH, uint ratio) internal view returns (uint) {\n        uint price = priceFeedTestnet.getPrice();\n        require(price > 0);\n        uint minETH = ratio.mul(LUSD_GAS_COMPENSATION).div(price);\n        require(actorBalance > minETH);\n        uint ETH = minETH + _ETH % (actorBalance - minETH);\n        return ETH;\n    }\n\n    function getAdjustedLUSD(uint ETH, uint _LUSDAmount, uint ratio) internal view returns (uint) {\n        uint price = priceFeedTestnet.getPrice();\n        uint LUSDAmount = _LUSDAmount;\n        uint compositeDebt = LUSDAmount.add(LUSD_GAS_COMPENSATION);\n        uint ICR = LiquityMath._computeCR(ETH, compositeDebt, price);\n        if (ICR < ratio) {\n            compositeDebt = ETH.mul(price).div(ratio);\n            LUSDAmount = compositeDebt.sub(LUSD_GAS_COMPENSATION);\n        }\n        return LUSDAmount;\n    }\n\n    function openTroveExt(uint _i, uint _ETH, uint _LUSDAmount) public payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        EchidnaProxy echidnaProxy = echidnaProxies[actor];\n        uint actorBalance = address(echidnaProxy).balance;\n\n        // we pass in CCR instead of MCR in case it’s the first one\n        uint ETH = getAdjustedETH(actorBalance, _ETH, CCR);\n        uint LUSDAmount = getAdjustedLUSD(ETH, _LUSDAmount, CCR);\n\n        //console.log('ETH', ETH);\n        //console.log('LUSDAmount', LUSDAmount);\n\n        echidnaProxy.openTrovePrx(ETH, LUSDAmount, address(0));\n\n        numberOfTroves = troveManager.getTroveOwnersCount();\n        assert(numberOfTroves > 0);\n        // canary\n        //assert(numberOfTroves == 0);\n    }\n\n    function openTroveRawExt(uint _i, uint _ETH, uint _LUSDAmount, address _hint) public payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].openTrovePrx(_ETH, _LUSDAmount, _hint);\n    }\n\n    function addCollExt(uint _i, uint _ETH) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        EchidnaProxy echidnaProxy = echidnaProxies[actor];\n        uint actorBalance = address(echidnaProxy).balance;\n\n        uint ETH = getAdjustedETH(actorBalance, _ETH, MCR);\n\n        echidnaProxy.addCollPrx(ETH, address(0));\n    }\n\n    function addCollRawExt(uint _i, uint _ETH, address _hint) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].addCollPrx(_ETH, _hint);\n    }\n\n    function withdrawCollExt(uint _i, uint _amount, address _hint) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].withdrawCollPrx(_amount, _hint);\n    }\n\n    function withdrawLUSDExt(uint _i, uint _amount, address _hint) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].withdrawLUSDPrx(_amount, _hint);\n    }\n\n    function repayLUSDExt(uint _i, uint _amount, address _hint) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].repayLUSDPrx(_amount, _hint);\n    }\n\n    function closeTroveExt(uint _i) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].closeTrovePrx();\n    }\n\n    function adjustTroveExt(uint _i, uint _ETH, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        EchidnaProxy echidnaProxy = echidnaProxies[actor];\n        uint actorBalance = address(echidnaProxy).balance;\n\n        uint ETH = getAdjustedETH(actorBalance, _ETH, MCR);\n        uint debtChange = _debtChange;\n        if (_isDebtIncrease) {\n            // TODO: add current amount already withdrawn:\n            debtChange = getAdjustedLUSD(ETH, uint(_debtChange), MCR);\n        }\n        // TODO: collWithdrawal, debtChange\n        echidnaProxy.adjustTrovePrx(ETH, _collWithdrawal, debtChange, _isDebtIncrease, address(0));\n    }\n\n    function adjustTroveRawExt(uint _i, uint _ETH, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _hint) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].adjustTrovePrx(_ETH, _collWithdrawal, _debtChange, _isDebtIncrease, _hint);\n    }\n\n    // Pool Manager\n\n    function provideToSPExt(uint _i, uint _amount, address _frontEndTag) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].provideToSPPrx(_amount, _frontEndTag);\n    }\n\n    function withdrawFromSPExt(uint _i, uint _amount) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].withdrawFromSPPrx(_amount);\n    }\n\n    // LUSD Token\n\n    function transferExt(uint _i, address recipient, uint256 amount) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].transferPrx(recipient, amount);\n    }\n\n    function approveExt(uint _i, address spender, uint256 amount) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].approvePrx(spender, amount);\n    }\n\n    function transferFromExt(uint _i, address sender, address recipient, uint256 amount) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].transferFromPrx(sender, recipient, amount);\n    }\n\n    function increaseAllowanceExt(uint _i, address spender, uint256 addedValue) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].increaseAllowancePrx(spender, addedValue);\n    }\n\n    function decreaseAllowanceExt(uint _i, address spender, uint256 subtractedValue) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].decreaseAllowancePrx(spender, subtractedValue);\n    }\n\n    // PriceFeed\n\n    function setPriceExt(uint256 _price) external {\n        bool result = priceFeedTestnet.setPrice(_price);\n        assert(result);\n    }\n\n    // --------------------------\n    // Invariants and properties\n    // --------------------------\n\n    function echidna_canary_number_of_troves() public view returns(bool) {\n        if (numberOfTroves > 20) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function echidna_canary_active_pool_balance() public view returns(bool) {\n        if (address(activePool).balance > 0) {\n            return false;\n        }\n        return true;\n    }\n\n    function echidna_troves_order() external view returns(bool) {\n        uint price = priceFeedTestnet.getPrice();\n\n        address currentTrove = sortedTroves.getFirst();\n        address nextTrove = sortedTroves.getNext(currentTrove);\n\n        while (currentTrove != address(0) && nextTrove != address(0)) {\n            if (troveManager.getCurrentICR(nextTrove, price) > troveManager.getCurrentICR(currentTrove, price)) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            currentTrove = nextTrove;\n            nextTrove = sortedTroves.getNext(currentTrove);\n        }\n\n        return true;\n    }\n\n    /**\n     * Status\n     * Minimum debt (gas compensation)\n     * Stake > 0\n     */\n    function echidna_trove_properties() public view returns(bool) {\n        address currentTrove = sortedTroves.getFirst();\n        while (currentTrove != address(0)) {\n            // Status\n            if (TroveManager.Status(troveManager.getTroveStatus(currentTrove)) != TroveManager.Status.active) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            // Minimum debt (gas compensation)\n            if (troveManager.getTroveDebt(currentTrove) < LUSD_GAS_COMPENSATION) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            // Stake > 0\n            if (troveManager.getTroveStake(currentTrove) == 0) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            currentTrove = sortedTroves.getNext(currentTrove);\n        }\n        return true;\n    }\n\n    function echidna_ETH_balances() public view returns(bool) {\n        if (address(troveManager).balance > 0) {\n            return false;\n        }\n\n        if (address(borrowerOperations).balance > 0) {\n            return false;\n        }\n\n        if (address(activePool).balance != activePool.getETH()) {\n            return false;\n        }\n\n        if (address(defaultPool).balance != defaultPool.getETH()) {\n            return false;\n        }\n\n        if (address(stabilityPool).balance != stabilityPool.getETH()) {\n            return false;\n        }\n\n        if (address(lusdToken).balance > 0) {\n            return false;\n        }\n    \n        if (address(priceFeedTestnet).balance > 0) {\n            return false;\n        }\n        \n        if (address(sortedTroves).balance > 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // TODO: What should we do with this? Should it be allowed? Should it be a canary?\n    function echidna_price() public view returns(bool) {\n        uint price = priceFeedTestnet.getPrice();\n        \n        if (price == 0) {\n            return false;\n        }\n        // Uncomment to check that the condition is meaningful\n        //else return false;\n\n        return true;\n    }\n\n    // Total LUSD matches\n    function echidna_LUSD_global_balances() public view returns(bool) {\n        uint totalSupply = lusdToken.totalSupply();\n        uint gasPoolBalance = lusdToken.balanceOf(GAS_POOL_ADDRESS);\n\n        uint activePoolBalance = activePool.getLUSDDebt();\n        uint defaultPoolBalance = defaultPool.getLUSDDebt();\n        if (totalSupply != activePoolBalance + defaultPoolBalance) {\n            return false;\n        }\n\n        uint stabilityPoolBalance = stabilityPool.getTotalLUSDDeposits();\n        address currentTrove = sortedTroves.getFirst();\n        uint trovesBalance;\n        while (currentTrove != address(0)) {\n            trovesBalance += lusdToken.balanceOf(address(currentTrove));\n            currentTrove = sortedTroves.getNext(currentTrove);\n        }\n        // we cannot state equality because tranfers are made to external addresses too\n        if (totalSupply <= stabilityPoolBalance + trovesBalance + gasPoolBalance) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /*\n    function echidna_test() public view returns(bool) {\n        return true;\n    }\n    */\n}\n"
    },
    "contracts/TestContracts/PriceFeedTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/IPriceFeed.sol\";\n\n/*\n* PriceFeed placeholder for testnet and development. The price is simply set manually and saved in a state \n* variable. The contract does not connect to a live Chainlink price feed. \n*/\ncontract PriceFeedTestnet is IPriceFeed {\n    \n    uint256 private _price = 200 * 1e18;\n\n    // --- Functions ---\n\n    function getPrice() external view override returns (uint256) {\n        return _price;\n    }\n\n    // Manual external price setter.\n    function setPrice(uint256 price) external returns (bool) {\n        _price = price;\n        return true;\n    }\n}\n"
    },
    "contracts/TestContracts/FunctionCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport '../Interfaces/ITroveManager.sol';\nimport '../Interfaces/ISortedTroves.sol';\nimport '../Interfaces/IPriceFeed.sol';\nimport '../Dependencies/LiquityMath.sol';\n\n/* Wrapper contract - used for calculating gas of read-only and internal functions. \nNot part of the Liquity application. */\ncontract FunctionCaller {\n\n    ITroveManager troveManager;\n    address public troveManagerAddress;\n\n    ISortedTroves sortedTroves;\n    address public sortedTrovesAddress;\n\n    IPriceFeed priceFeed;\n    address public priceFeedAddress;\n\n    // --- Dependency setters ---\n\n    function setTroveManagerAddress(address _troveManagerAddress) external {\n        troveManagerAddress = _troveManagerAddress;\n        troveManager = ITroveManager(_troveManagerAddress);\n    }\n    \n    function setSortedTrovesAddress(address _sortedTrovesAddress) external {\n        troveManagerAddress = _sortedTrovesAddress;\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n    }\n\n     function setPriceFeedAddress(address _priceFeedAddress) external {\n        priceFeedAddress = _priceFeedAddress;\n        priceFeed = IPriceFeed(_priceFeedAddress);\n    }\n\n    // --- Non-view wrapper functions used for calculating gas ---\n    \n    function troveManager_getCurrentICR(address _address, uint _price) external returns (uint) {\n        return troveManager.getCurrentICR(_address, _price);  \n    }\n\n    function sortedTroves_findInsertPosition(uint _ICR, uint _price, address _prevId, address _nextId) external returns (address, address) {\n        return sortedTroves.findInsertPosition(_ICR, _price, _prevId, _nextId);\n    }\n}\n"
    },
    "contracts/TestContracts/GrowthTokenTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../LQTY/LQTYToken.sol\";\n\ncontract LQTYTokenTester is LQTYToken {\n    constructor\n    (\n        address _communityIssuanceAddress, \n        address _lqtyStakingAddress, \n        address _lockupFactoryAddress\n    ) \n        public \n        LQTYToken \n    (\n        _communityIssuanceAddress,\n        _lqtyStakingAddress,\n        _lockupFactoryAddress\n    )\n    {} \n\n    function unprotectedMint(address account, uint256 amount) external {\n        // No check for the caller here\n\n        _mint(account, amount);\n    }\n\n    function unprotectedSendToLQTYStaking(address _sender, uint256 _amount) external {\n        // No check for the caller here\n        \n        if (_isFirstYear()) {_requireSenderIsNotDeployer(_sender);}\n        _transfer(_sender, lqtyStakingAddress, _amount);\n    }\n\n    function callInternalApprove(address owner, address spender, uint256 amount) external returns (bool) {\n        _approve(owner, spender, amount);\n    }\n\n    function callInternalTransfer(address sender, address recipient, uint256 amount) external returns (bool) {\n        _transfer(sender, recipient, amount);\n    }\n\n    function getChainId() external pure returns (uint256 chainID) {\n        //return _chainID(); // it’s private\n        assembly {\n            chainID := chainid()\n        }\n    }\n}"
    },
    "contracts/TestContracts/LiquityMathTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/LiquityMath.sol\";\n\n/* Tester contract for math functions in Math.sol library. */\n\ncontract LiquityMathTester {\n    \n    // Non-view wrapper for gas test\n    function callDecPowTx(uint _base, uint _n) external returns (uint) {\n        return LiquityMath._decPow(_base, _n);\n    }\n\n    // External wrapper\n    function callDecPow(uint _base, uint _n) external pure returns (uint) {\n        return LiquityMath._decPow(_base, _n);\n    }\n}\n"
    },
    "contracts/TestContracts/LiquitySafeMath128Tester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Dependencies/LiquitySafeMath128.sol\";\n\n/* Tester contract for math functions in LiquitySafeMath128.sol library. */\n\ncontract LiquitySafeMath128Tester {\n    using LiquitySafeMath128 for uint128;\n\n    function add(uint128 a, uint128 b) external pure returns (uint128) {\n        return a.add(b);\n    }\n\n    function sub(uint128 a, uint128 b) external pure returns (uint128) {\n        return a.sub(b);\n    }\n}\n"
    },
    "contracts/TestContracts/LUSDTokenCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/ILUSDToken.sol\";\n\ncontract LUSDTokenCaller {\n    ILUSDToken LUSD;\n\n    function setLUSD(ILUSDToken _LUSD) external {\n        LUSD = _LUSD;\n    }\n\n    function lusdMint(address _account, uint _amount) external {\n        LUSD.mint(_account, _amount);\n    }\n\n    function lusdBurn(address _account, uint _amount) external {\n        LUSD.burn(_account, _amount);\n    }\n\n    function lusdSendToPool(address _sender,  address _poolAddress, uint256 _amount) external {\n        LUSD.sendToPool(_sender, _poolAddress, _amount);\n    }\n\n    function lusdReturnFromPool(address _poolAddress, address _receiver, uint256 _amount ) external {\n        LUSD.returnFromPool(_poolAddress, _receiver, _amount);\n    }\n}\n"
    },
    "contracts/TestContracts/LUSDTokenTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../LUSDToken.sol\";\n\ncontract LUSDTokenTester is LUSDToken {\n    \n    constructor( \n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress\n    ) public LUSDToken(_troveManagerAddress,\n                      _stabilityPoolAddress,\n                      _borrowerOperationsAddress) {}\n    \n    function unprotectedMint(address _account, uint256 _amount) external {\n        // No check on caller here\n\n        _mint(_account, _amount);\n    }\n\n    function unprotectedBurn(address _account, uint _amount) external {\n        // No check on caller here\n        \n        _burn(_account, _amount);\n    }\n\n    function unprotectedSendToPool(address _sender,  address _poolAddress, uint256 _amount) external {\n        // No check on caller here\n\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function unprotectedReturnFromPool(address _poolAddress, address _receiver, uint256 _amount ) external {\n        // No check on caller here\n\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    function callInternalApprove(address owner, address spender, uint256 amount) external returns (bool) {\n        _approve(owner, spender, amount);\n    }\n\n    function getChainId() external pure returns (uint256 chainID) {\n        //return _chainID(); // it’s private\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    function getDigest(address owner, address spender, uint amount, uint nonce, uint deadline) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(\n                uint16(0x1901),\n                domainSeparator(),\n                keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, nonce, deadline))\n            )\n        );\n    }\n\n    function recoverAddress(bytes32 digest, uint8 v, bytes32 r, bytes32 s) external pure returns (address) {\n        return ecrecover(digest, v, r, s);\n    }\n}\n"
    },
    "contracts/TestContracts/NonPayable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n//import \"../Dependencies/console.sol\";\n\n\ncontract NonPayable {\n    bool isPayable;\n\n    function setPayable(bool _isPayable) external {\n        isPayable = _isPayable;\n    }\n\n    function forward(address _dest, bytes calldata _data) external payable {\n        (bool success, bytes memory returnData) = _dest.call{ value: msg.value }(_data);\n        //console.logBytes(returnData);\n        require(success, string(returnData));\n    }\n\n    receive() external payable {\n        require(isPayable);\n    }\n}\n"
    },
    "contracts/TestContracts/SortedTrovesTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/ISortedTroves.sol\";\n\n\ncontract SortedTrovesTester {\n    ISortedTroves sortedTroves;\n\n    function setSortedTroves(address _sortedTrovesAddress) external {\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n    }\n\n    function insert(address _id, uint256 _ICR, uint _price, address _prevId, address _nextId) external {\n        sortedTroves.insert(_id, _ICR, _price, _prevId, _nextId);\n    }\n\n    function remove(address _id) external {\n        sortedTroves.remove(_id);\n    }\n\n    function reInsert(address _id, uint256 _newICR, uint _price, address _prevId, address _nextId) external {\n        sortedTroves.reInsert(_id, _newICR, _price, _prevId, _nextId);\n    }\n\n    function getCurrentICR(address, uint) external pure returns (uint) {\n        return 1;\n    }\n}\n"
    },
    "contracts/TestContracts/StabilityPoolTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../StabilityPool.sol\";\n\ncontract StabilityPoolTester is StabilityPool {\n    \n    function unprotectedPayable() external payable {\n        ETH = ETH.add(msg.value);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}